<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„É©„É≥„ÉÄ„É†ÈÉΩÂ∏Ç„Éû„ÉÉ„Éó„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
        }

        #player-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: right;
        }
        #time-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        button {
            margin-top: 10px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none; /* ÂàùÊúüÁä∂ÊÖã„Åß„ÅØÈùûË°®Á§∫ */
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #joystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 75px;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            transform: translate(-50%, -50%);
        }
        #jump-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            touch-action: none;
        }
        #camera-switch {
            margin-left: 10px;
            background-color: #2196F3;
        }
        #camera-switch:hover {
            background-color: #1976D2;
        }
        
        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Ç≤„Éº„Ç∏„ÅÆ„Çπ„Çø„Ç§„É´ */
        #status-container {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        .status-bar {
            width: 100%;
            height: 15px;
            margin: 5px 0;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        
        .status-label {
            color: white;
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        #health-fill { background-color: #ff4444; }
        #hunger-fill { background-color: #ffaa44; }
        #thirst-fill { background-color: #44aaff; }
        #bleeding-fill { background-color: #ff44ff; }
        #hygiene-fill { background-color: #44ff44; }
        #temperature-fill { background-color: #ffff44; }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        #inventory-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            height: 60%;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            display: none;
            color: white;
        }
        
        #inventory-list {
            height: calc(100% - 40px);
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .inventory-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .inventory-item button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
        }
        
        .inventory-item button:hover {
            background: #45a049;
        }
        
        .inventory-item button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .control-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .control-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            touch-action: none;
        }
        
        .control-button:active {
            background: rgba(255, 255, 255, 0.3);
        }
        
        #attack-button {
            background: rgba(255, 0, 0, 0.3);
        }
        
        #jump-button {
            background: rgba(0, 255, 0, 0.3);
        }
        
        #bag-button {
            background: rgba(0, 0, 255, 0.3);
        }
        
        #camera-button {
            background: rgba(255, 255, 0, 0.3);
        }
    </style>
</head>
<body>

    
    <div id="player-info">
        <div id="position">‰ΩçÁΩÆ: X: 0.00, Y: 0.00, Z: 0.00</div>
        <div id="biome">„Éê„Ç§„Ç™„Éº„É†: ÈÉΩÂ∏Ç</div>
        <div id="zombie-count">„Çæ„É≥„ÉìÊï∞: 0</div>
    </div>
    
    <div id="time-display">
        <div id="current-time">ÊôÇÈñì: 06:00</div>
    </div>
    
    <div id="crosshair"></div>
    <div id="joystick">
        <div id="joystick-knob"></div>
    </div>
    
    <div class="control-buttons">
        <div id="attack-button" class="control-button">üî´</div>
        <div id="jump-button" class="control-button">‚¨ÜÔ∏è</div>
        <div id="bag-button" class="control-button">üéí</div>
        <div id="camera-button" class="control-button">üì∑</div>
    </div>
    
    <!-- „Çπ„ÉÜ„Éº„Çø„Çπ„Ç≤„Éº„Ç∏ -->
    <div id="status-container">
        <div class="status-label">‰ΩìÂäõ</div>
        <div class="status-bar"><div id="health-fill" class="status-fill"></div></div>
        <div class="status-label">Á©∫ËÖπ</div>
        <div class="status-bar"><div id="hunger-fill" class="status-fill"></div></div>
        <div class="status-label">Âñâ„ÅÆÊ∏á„Åç</div>
        <div class="status-bar"><div id="thirst-fill" class="status-fill"></div></div>
        <div class="status-label">Âá∫Ë°Ä</div>
        <div class="status-bar"><div id="bleeding-fill" class="status-fill"></div></div>
        <div class="status-label">Ë°õÁîüÁä∂ÊÖã</div>
        <div class="status-bar"><div id="hygiene-fill" class="status-fill"></div></div>
        <div class="status-label">‰ΩìÊ∏©</div>
        <div class="status-bar"><div id="temperature-fill" class="status-fill"></div></div>
    </div>
    
    <!-- „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁîªÈù¢ -->
    <div id="game-over">
        <h2>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h2>
        <p>„ÅÇ„Å™„Åü„ÅØÁîüÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü...</p>
        <button onclick="location.reload()">„É™„Éà„É©„Ç§</button>
    </div>
    

    
    <!-- „Ç§„É≥„Éô„É≥„Éà„É™„Éë„Éç„É´ -->
    <div id="inventory-panel">
        <h2>ÊåÅ„Å°Áâ©</h2>
        <div id="inventory-list"></div>
    </div>
    
    <!-- ÊúÄÊñ∞„Éê„Éº„Ç∏„Éß„É≥„ÅÆThree.js„Çí‰ΩøÁî® -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- OrbitControls„ÅØÂà•ÈÄî„Ç§„É≥„Éù„Éº„Éà (Three.js„ÅÆ‰∏ÄÈÉ®„Å®„Åó„Å¶) -->
    <script>
        // OrbitControls„ÅÆÂÆüË£Ö (Three.js„Å´Âê´„Åæ„Çå„Å™„Åè„Å™„Å£„Åü„Åü„ÇÅÁõ¥Êé•ÂÆüË£Ö)
        // https://github.com/mrdoob/three.js/blob/dev/examples/jsm/controls/OrbitControls.js „ÇíÂü∫„Å´Á∞°Áï•Âåñ
        THREE.OrbitControls = function(object, domElement) {
            this.object = object;
            this.domElement = (domElement !== undefined) ? domElement : document;
            
            // API
            this.enabled = true;
            this.center = new THREE.Vector3();
            
            this.enableDamping = false;
            this.dampingFactor = 0.25;
            
            this.minDistance = 0;
            this.maxDistance = Infinity;
            
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            
            // „Éû„Ç¶„Çπ„Éú„Çø„É≥
            this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            
            // ÂÜÖÈÉ®Áä∂ÊÖã
            var scope = this;
            
            var EPS = 0.000001;
            
            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();
            
            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            
            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();
            
            var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };
            var state = STATE.NONE;
            
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó‰∏≠„Å´Êõ¥Êñ∞„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„ÇãÂÄ§
            this.update = function() {
                // „Ç´„É°„É©„ÅÆ‰ΩçÁΩÆ„Çí‰∏≠ÂøÉÁÇπ„ÇíÂü∫Ê∫ñ„Å´Êõ¥Êñ∞
                var position = scope.object.position;
                
                position.clampLength(scope.minDistance, scope.maxDistance);
                
                return false;
            };
            
            function getAutoRotationAngle() {
                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }
            
            function getZoomScale() {
                return Math.pow(0.95, scope.zoomSpeed);
            }
            
            function onMouseDown(event) {
                event.preventDefault();
                
                if (scope.enabled === false) return;
                
                if (event.button === scope.mouseButtons.ROTATE) {
                    state = STATE.ROTATE;
                    rotateStart.set(event.clientX, event.clientY);
                } else if (event.button === scope.mouseButtons.DOLLY) {
                    state = STATE.DOLLY;
                    dollyStart.set(event.clientX, event.clientY);
                } else if (event.button === scope.mouseButtons.PAN) {
                    state = STATE.PAN;
                    panStart.set(event.clientX, event.clientY);
                }
                
                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);
            }
            
            function onMouseMove(event) {
                event.preventDefault();
                
                if (scope.enabled === false) return;
                
                if (state === STATE.ROTATE) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart);
                    
                    // ÂõûËª¢Âá¶ÁêÜ
                    rotateLeft(2 * Math.PI * rotateDelta.x / scope.domElement.clientWidth);
                    rotateUp(2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight);
                    
                    rotateStart.copy(rotateEnd);
                } else if (state === STATE.DOLLY) {
                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart);
                    
                    if (dollyDelta.y > 0) {
                        dollyOut(getZoomScale());
                    } else if (dollyDelta.y < 0) {
                        dollyIn(getZoomScale());
                    }
                    
                    dollyStart.copy(dollyEnd);
                } else if (state === STATE.PAN) {
                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart);
                    
                    pan(panDelta.x, panDelta.y);
                    
                    panStart.copy(panEnd);
                }
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove, false);
                document.removeEventListener('mouseup', onMouseUp, false);
                
                state = STATE.NONE;
            }
            
            function onMouseWheel(event) {
                event.preventDefault();
                event.stopPropagation();
                
                if (event.deltaY < 0) {
                    dollyIn(getZoomScale());
                } else if (event.deltaY > 0) {
                    dollyOut(getZoomScale());
                }
            }
            
            function onKeyDown(event) {
                if (scope.enabled === false) return;
                
                switch (event.keyCode) {
                    case 38: // up arrow
                        dollyIn(getZoomScale());
                        break;
                    case 40: // down arrow
                        dollyOut(getZoomScale());
                        break;
                }
            }
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            scope.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
            scope.domElement.addEventListener('mousedown', onMouseDown, false);
            scope.domElement.addEventListener('wheel', onMouseWheel, false);
            scope.domElement.addEventListener('keydown', onKeyDown, false);
            
            // „Ç´„É°„É©Êìç‰ΩúÈñ¢Êï∞
            function rotateLeft(angle) {
                // YËª∏Âë®„Çä„ÅÆÂõûËª¢
                var quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                scope.object.position.sub(scope.center);
                scope.object.position.applyQuaternion(quaternion);
                scope.object.position.add(scope.center);
                scope.object.lookAt(scope.center);
            }
            
            function rotateUp(angle) {
                // Ê∞¥Âπ≥Ëª∏Âë®„Çä„ÅÆÂõûËª¢
                var axis = new THREE.Vector3().crossVectors(scope.object.up, new THREE.Vector3().subVectors(scope.object.position, scope.center).normalize());
                var quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                scope.object.position.sub(scope.center);
                scope.object.position.applyQuaternion(quaternion);
                scope.object.position.add(scope.center);
                scope.object.lookAt(scope.center);
            }
            
            function dollyIn(dollyScale) {
                scale /= dollyScale;
            }
            
            function dollyOut(dollyScale) {
                scale *= dollyScale;
            }
            
            function pan(deltaX, deltaY) {
                var offset = new THREE.Vector3();
                
                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                
                // „Éë„Éº„Çπ„Éö„ÇØ„ÉÜ„Ç£„Éñ
                var position = scope.object.position;
                offset.copy(position).sub(scope.center);
                var targetDistance = offset.length();
                
                // Ë¶ñÈáéËßí„Å´Âü∫„Å•„ÅÑ„Å¶„Éë„É≥ÈÄüÂ∫¶„ÇíË®àÁÆó
                targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
                
                // Â∑¶Âè≥„Å´Âãï„Åã„Åô
                var movLeft = new THREE.Vector3();
                movLeft.crossVectors(scope.object.up, offset).setLength(2 * deltaX * targetDistance / element.clientHeight);
                
                // ‰∏ä‰∏ã„Å´Âãï„Åã„Åô
                var movUp = new THREE.Vector3();
                movUp.copy(scope.object.up).setLength(2 * deltaY * targetDistance / element.clientHeight);
                
                scope.object.position.add(movUp).add(movLeft);
                scope.center.add(movUp).add(movLeft);
                
                scope.object.lookAt(scope.center);
            }
            
            var scale = 1;
            
            this.update();
        };
        
        THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>
    
    <script>
        // „Éû„ÉÉ„Éó„ÅÆ„Éë„É©„É°„Éº„Çø
        const config = {
            width: 50,            // „Éû„ÉÉ„Éó„ÅÆÂπÖ
            height: 30,           // „Éû„ÉÉ„Éó„ÅÆÈ´ò„Åï
            minBlockSize: 1,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆÊúÄÂ∞è„Çµ„Ç§„Ç∫
            maxBlockSize: 6,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆÊúÄÂ§ß„Çµ„Ç§„Ç∫
            roadWidth: {
                min: 0.2,         // ÊúÄÂ∞èÈÅìË∑ØÂπÖ
                max: 0.5,         // ÊúÄÂ§ßÈÅìË∑ØÂπÖ
                main: 0.8         // „É°„Ç§„É≥ÈÅìË∑ØÂπÖ
            },
            subdivisionChance: 0.6, // „Éñ„É≠„ÉÉ„ÇØ„ÇíÂàÜÂâ≤„Åô„ÇãÁ¢∫Áéá
            maxSubdivisions: 4,   // ÊúÄÂ§ßÂàÜÂâ≤ÂõûÊï∞
            buildingHeight: {
                min: 0.3,         // ÊúÄÂ∞èÂª∫Áâ©È´ò„Åï
                max: 4,           // ÊúÄÂ§ßÂª∫Áâ©È´ò„Åï
                commercial: 3,    // ÂïÜÊ•≠Âú∞Âå∫„ÅÆÂª∫Áâ©È´ò„Åï
                residential: 1.5  // ‰ΩèÂÆÖÂú∞Âå∫„ÅÆÂª∫Áâ©È´ò„Åï
            },
            parkChance: 0.2,      // ÂÖ¨Âúí„ÅåÁîüÊàê„Åï„Çå„ÇãÁ¢∫Áéá
            treeSpacing: 20,      // Êú®„ÅÆÈñìÈöî
            biomeSize: 25,        // „Éê„Ç§„Ç™„Éº„É†„ÅÆ„Çµ„Ç§„Ç∫Ôºà100„Åã„Çâ25„Å´Â§âÊõ¥Ôºâ
            colors: {
                background: 0x8888ff, // ËÉåÊôØ„ÅÆËâ≤
                highlight: 0x8888ff   // „Éè„Ç§„É©„Ç§„Éà„ÅÆËâ≤
            },
            biomes: {
                city: {
                    name: "ÈÉΩÂ∏Ç",
                    colors: {
                        road: 0x228822,       // ÈÅìË∑Ø„ÅÆËâ≤ÔºàÊöó„ÅÑ„Ç∞„É¨„ÉºÔºâ
                        ground: 0x228822,     // Â∫ä„ÅÆËâ≤Ôºà„Çà„ÇäÊöó„ÅÑ„Ç∞„É¨„ÉºÔºâ
                        block: 0x228822,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆËâ≤
                        park: 0x228822,       // ÂÖ¨Âúí„ÅÆËâ≤
                        tree: 0x228822        // Êú®„ÅÆËâ≤
                    }
                },
                grassland: {
                    name: "ËçâÂéü",
                    colors: {
                        road: 0x228822,       // ÈÅìË∑Ø„ÅÆËâ≤ÔºàÈªÑÂúüËâ≤Ôºâ
                        ground: 0x228822,     // Â∫ä„ÅÆËâ≤ÔºàÊòé„Çã„ÅÑÁ∑ëÔºâ
                        block: 0x228822,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆËâ≤
                        park: 0x228822,       // ÂÖ¨Âúí„ÅÆËâ≤
                        tree: 0x228822        // Êú®„ÅÆËâ≤
                    }
                },
                forest: {
                    name: "Ê£ÆÊûó",
                    colors: {
                        road: 0x228822,       // ÈÅìË∑Ø„ÅÆËâ≤ÔºàÊöó„ÅÑÁ∑ëÔºâ
                        ground: 0x228822,     // Â∫ä„ÅÆËâ≤ÔºàÊ∑±„ÅÑÁ∑ëÔºâ
                        block: 0x228822,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆËâ≤
                        park: 0x228822,       // ÂÖ¨Âúí„ÅÆËâ≤
                        tree: 0x228822        // Êú®„ÅÆËâ≤
                    }
                },
                rural: {
                    name: "Ëæ≤Êùë",
                    colors: {
                        road: 0x8B4513,       // ÈÅìË∑Ø„ÅÆËâ≤ÔºàËå∂Ëâ≤Ôºâ
                        ground: 0xA67C52,     // Â∫ä„ÅÆËâ≤ÔºàÊòé„Çã„ÅÑËå∂Ëâ≤Ôºâ
                        block: 0x6B4423,      // „Éñ„É≠„ÉÉ„ÇØ„ÅÆËâ≤
                        park: 0x4A7C59,       // ÂÖ¨Âúí„ÅÆËâ≤
                        tree: 0x31572C        // Êú®„ÅÆËâ≤
                    }
                }
            }
        };

        // „Ç∑„Éº„É≥„ÅÆÂàùÊúüÂåñ
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.colors.background);
        
        // „Ç´„É°„É©„ÅÆË®≠ÂÆö
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const topDownCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        let currentCamera = camera;
        
        // „Ç´„É°„É©„ÅÆÂàùÊúü‰ΩçÁΩÆË®≠ÂÆö
        camera.position.set(0, 0.1, 0.3);
        topDownCamera.position.set(0, 5, 5);
        topDownCamera.lookAt(0, 0, 0);
        
        // „É¨„É≥„ÉÄ„É©„Éº„ÅÆË®≠ÂÆö
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // „Ç≥„É≥„Éà„É≠„Éº„É´„ÅÆË®≠ÂÆö
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.center.set(0, 0, 0);
        
        // ÂÖâÊ∫ê„ÅÆË®≠ÂÆö
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        // BSP„ÉÑ„É™„ÉºÈ¢®„ÅÆ„Éñ„É≠„ÉÉ„ÇØÂàÜÂâ≤„Ç¢„É´„Ç¥„É™„Ç∫„É†„Åß„Éû„ÉÉ„Éó„ÇíÁîüÊàê„Åô„Çã
        class Block {
            constructor(x, y, width, height, depth = 0.5) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.subdivided = false;
                this.children = [];
            }
            
            subdivide() {
                if (this.subdivided || 
                    this.width <= config.minBlockSize || 
                    this.height <= config.minBlockSize) {
                    return false;
                }
                
                // ÂàÜÂâ≤ÂõûÊï∞„ÅÆÂà∂Èôê
                if (Math.random() > Math.pow(config.subdivisionChance, this.getDepth())) {
                    return false;
                }
                
                // Ê∞¥Âπ≥„Åæ„Åü„ÅØÂûÇÁõ¥„Å´ÂàÜÂâ≤„Åô„Çã„Åã„ÇíÊ±∫ÂÆö
                let horizontal = Math.random() < 0.5;
                
                // ÁèæÂú®„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„Çµ„Ç§„Ç∫„Å´Âøú„Åò„Å¶ÂàÜÂâ≤ÊñπÂêë„ÇíË™øÊï¥
                if (this.width > this.height * 1.5) {
                    horizontal = false; // ÂπÖ„ÅåÈ´ò„Åï„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅØÊ∞¥Âπ≥ÂàÜÂâ≤„ÇíÂÑ™ÂÖà
                } else if (this.height > this.width * 1.5) {
                    horizontal = true;  // È´ò„Åï„ÅåÂπÖ„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅØÂûÇÁõ¥ÂàÜÂâ≤„ÇíÂÑ™ÂÖà
                }
                
                // ÂàÜÂâ≤‰ΩçÁΩÆ„ÇíÊ±∫ÂÆöÔºàÁ´Ø„Åã„ÇâÂ∞ë„ÅóÂÜÖÂÅ¥Ôºâ
                const minSplit = 0.3; // ÊúÄÂ∞èÂàÜÂâ≤ÊØîÁéá
                const maxSplit = 0.7; // ÊúÄÂ§ßÂàÜÂâ≤ÊØîÁéá
                const splitRatio = minSplit + Math.random() * (maxSplit - minSplit);
                
                // ÂÆüÈöõ„ÅÆÂàÜÂâ≤Âá¶ÁêÜ
                if (horizontal) {
                    // Ê∞¥Âπ≥ÂàÜÂâ≤
                    const splitPoint = Math.floor(this.height * splitRatio);
                    if (splitPoint < config.minBlockSize || 
                        this.height - splitPoint < config.minBlockSize) {
                        return false;
                    }
                    
                    this.children.push(
                        new Block(this.x, this.y, this.width, splitPoint, this.depth + 1),
                        new Block(this.x, this.y + splitPoint, this.width, this.height - splitPoint, this.depth + 1)
                    );
                } else {
                    // ÂûÇÁõ¥ÂàÜÂâ≤
                    const splitPoint = Math.floor(this.width * splitRatio);
                    if (splitPoint < config.minBlockSize || 
                        this.width - splitPoint < config.minBlockSize) {
                        return false;
                    }
                    
                    this.children.push(
                        new Block(this.x, this.y, splitPoint, this.height, this.depth + 1),
                        new Block(this.x + splitPoint, this.y, this.width - splitPoint, this.height, this.depth + 1)
                    );
                }
                
                this.subdivided = true;
                
                // ÂÜçÂ∏∞ÁöÑ„Å´Â≠ê„Éñ„É≠„ÉÉ„ÇØ„ÇÇÂàÜÂâ≤„ÇíË©¶„Åø„Çã
                for (const child of this.children) {
                    child.subdivide();
                }
                
                return true;
            }
            
            getDepth() {
                let depth = 0;
                let current = this;
                while (current.parent) {
                    depth++;
                    current = current.parent;
                }
                return depth;
            }
            
            getLeafBlocks() {
                if (!this.subdivided) {
                    return [this];
                }
                
                let leaves = [];
                for (const child of this.children) {
                    leaves = leaves.concat(child.getLeafBlocks());
                }
                return leaves;
            }
        }
        
        // „Éû„ÉÉ„ÉóÁîüÊàê„ÇØ„É©„Çπ
        class CityMap {
            constructor(config, scene) {
                this.config = config;
                this.scene = scene;
                this.blocks = [];
                this.meshes = new THREE.Group();
                this.buildOutline = new THREE.Group();
                this.roadNetwork = new THREE.Group();
                this.mapSections = new Map(); // „Éû„ÉÉ„Éó„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁÆ°ÁêÜ
                this.currentSection = '0,0'; // ÁèæÂú®„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥
            }
            
            // „Éê„Ç§„Ç™„Éº„É†„ÇíÊ±∫ÂÆö„Åô„ÇãÈñ¢Êï∞
            getBiome(x, z) {
                // „Éê„Ç§„Ç™„Éº„É†„ÅÆ„Çµ„Ç§„Ç∫„Å´Âü∫„Å•„ÅÑ„Å¶„Éê„Ç§„Ç™„Éº„É†„ÇíÊ±∫ÂÆö
                const biomeX = Math.floor(x / this.config.biomeSize);
                const biomeZ = Math.floor(z / this.config.biomeSize);
                
                // „Éê„Ç§„Ç™„Éº„É†„ÅÆÁ®ÆÈ°û„ÇíÊ±∫ÂÆöÔºà‰ΩçÁΩÆ„Å´Âü∫„Å•„ÅÑ„Å¶Ê±∫ÂÆöÔºâ
                const biomeTypes = Object.keys(this.config.biomes);
                const index = Math.abs((biomeX * 7919 + biomeZ * 6037)) % biomeTypes.length;
                const biomeType = biomeTypes[index];
                
                return this.config.biomes[biomeType] || this.config.biomes.city;
            }
            
            // Ëâ≤„ÅÆË£úÈñì„ÇíË°å„ÅÜ„Éò„É´„Éë„ÉºÈñ¢Êï∞
            interpolateColor(color1, color2, factor) {
                const r1 = (color1 >> 16) & 255;
                const g1 = (color1 >> 8) & 255;
                const b1 = color1 & 255;
                
                const r2 = (color2 >> 16) & 255;
                const g2 = (color2 >> 8) & 255;
                const b2 = color2 & 255;
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return (r << 16) | (g << 8) | b;
            }
            
            // ÂàùÊúü„Éû„ÉÉ„Éó„ÇíÁîüÊàê
            generate() {
                // ‰∏≠ÂøÉ„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥Ôºà0,0Ôºâ„ÇíÁîüÊàê
                this.generateSection(0, 0);
                
                // Âë®Âõ≤„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÇÇÁîüÊàê
                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x !== 0 || z !== 0) {
                            this.generateSection(x, z);
                        }
                    }
                }

                // „Ç¢„Ç§„ÉÜ„É†„ÇíÁîüÊàê
                this.generateItems();
                
                return this.meshes;
            }

            // „Ç¢„Ç§„ÉÜ„É†„ÇíÁîüÊàê„Åô„Çã„É°„ÇΩ„ÉÉ„Éâ
            generateItems() {
                const sectionSize = this.config.width;
                const totalSections = 9; // 3x3„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥
                const itemsPerSection = Math.floor(itemManager.maxItems / totalSections);

                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        const sectionX = x * sectionSize;
                        const sectionZ = z * sectionSize;

                        // ÂêÑ„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Ç¢„Ç§„ÉÜ„É†„ÇíÈÖçÁΩÆ
                        for (let i = 0; i < itemsPerSection; i++) {
                            const position = new THREE.Vector3(
                                sectionX + (Math.random() - 0.5) * sectionSize,
                                1,
                                sectionZ + (Math.random() - 0.5) * sectionSize
                            );

                            // Âª∫Áâ©„ÇÑÈöúÂÆ≥Áâ©„Å®„ÅÆË°ùÁ™Å„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                            if (!this.checkItemSpawnCollision(position)) {
                                const type = itemManager.itemTypes[Math.floor(Math.random() * itemManager.itemTypes.length)];
                                const item = new Item(type, position);
                                item.createMesh();
                                this.scene.add(item.mesh);
                                itemManager.items.add(item);
                            }
                        }
                    }
                }
            }

            // „Ç¢„Ç§„ÉÜ„É†„ÅÆ„Çπ„Éù„Éº„É≥‰ΩçÁΩÆ„ÅÆË°ùÁ™ÅÂà§ÂÆö
            checkItemSpawnCollision(position) {
                const raycaster = new THREE.Raycaster();
                raycaster.set(position, new THREE.Vector3(0, -1, 0));
                
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(position);
                        return distance < 5;
                    }
                    return false;
                });
                
                const intersects = raycaster.intersectObjects(nearbyObjects, true);
                
                for (const intersect of intersects) {
                    if (intersect.object.geometry.type === 'BoxGeometry' && 
                        intersect.distance < 0.1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // „Éñ„É≠„ÉÉ„ÇØ„ÇíÂÜçÂ∏∞ÁöÑ„Å´ÂàÜÂâ≤
            recursiveSubdivide(block, maxDepth) {
                if (maxDepth <= 0) return;
                
                let subdivided = false;
                for (const child of block.children) {
                    if (Math.random() < 0.7) { // 70%„ÅÆÁ¢∫Áéá„ÅßÂàÜÂâ≤„Åô„Çã
                        subdivided = child.subdivide() || subdivided;
                    }
                }
                
                if (subdivided) {
                    for (const child of block.children) {
                        this.recursiveSubdivide(child, maxDepth - 1);
                    }
                }
            }
            
            // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Ç≠„Éº„ÇíÁîüÊàê
            getSectionKey(x, z) {
                const sectionX = Math.floor(x / this.config.width);
                const sectionZ = Math.floor(z / this.config.height);
                return `${sectionX},${sectionZ}`;
            }
            
            // „Çª„ÇØ„Ç∑„Éß„É≥„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            hasSection(x, z) {
                return this.mapSections.has(this.getSectionKey(x, z));
            }
            
            // Êñ∞„Åó„ÅÑ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁîüÊàê
            generateSection(sectionX, sectionZ) {
                const key = `${sectionX},${sectionZ}`;
                if (this.mapSections.has(key)) return;
                
                // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
                const offsetX = sectionX * this.config.width;
                const offsetZ = sectionZ * this.config.height;
                
                // Êñ∞„Åó„ÅÑ„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Éû„ÉÉ„Éó„ÇíÁîüÊàê
                const sectionMap = new THREE.Group();
                sectionMap.position.set(offsetX, 0, offsetZ);
                
                // ÊúÄÂàù„ÅÆÂ§ß„Åç„Å™„Éñ„É≠„ÉÉ„ÇØ„Çí‰ΩúÊàê
                const rootBlock = new Block(0, 0, this.config.width, this.config.height);
                rootBlock.subdivide();
                
                // ÂàÜÂâ≤„ÇíË°å„ÅÜ
                this.recursiveSubdivide(rootBlock, this.config.maxSubdivisions);
                
                // ÂàÜÂâ≤Ê∏à„Åø„ÅÆ„É™„Éº„Éï„Éñ„É≠„ÉÉ„ÇØ„Å†„Åë„Çí‰øùÊåÅ
                const blocks = rootBlock.getLeafBlocks();
                
                // „É°„ÉÉ„Ç∑„É•„ÇíÁîüÊàê
                this.createSectionMeshes(blocks, sectionMap, offsetX, offsetZ);
                
                // „Çª„ÇØ„Ç∑„Éß„É≥„Çí‰øùÂ≠ò
                this.mapSections.set(key, {
                    meshes: sectionMap,
                    blocks: blocks
                });
                
                // „Ç∑„Éº„É≥„Å´ËøΩÂä†
                this.meshes.add(sectionMap);
            }
            
            // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„É°„ÉÉ„Ç∑„É•„ÇíÁîüÊàê
            createSectionMeshes(blocks, sectionMap, offsetX, offsetZ) {
                // „Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Éê„Ç§„Ç™„Éº„É†„ÇíÂèñÂæó
                const biome = this.getBiome(offsetX, offsetZ);
                
                // Âú∞Èù¢„Çí‰ΩúÊàêÔºàÈÅìË∑Ø„Å®Âêå„ÅòÈ´ò„Åï„Å´ÈÖçÁΩÆÔºâ
                const groundGeometry = new THREE.PlaneGeometry(
                    this.config.width * 1.5, 
                    this.config.height * 1.5
                );
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.ground,
                    roughness: 0.8,
                    metalness: 0.2,
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0.1;
                ground.receiveShadow = true;
                sectionMap.add(ground);
                
                // „Éê„Ç§„Ç™„Éº„É†„Åî„Å®„ÅÆÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
                switch(biome.name) {
                    case "ÈÉΩÂ∏Ç":
                        this.createCityBuildings(blocks, sectionMap, biome);
                        break;
                    case "Ê£ÆÊûó":
                        this.createForest(blocks, sectionMap, biome);
                        break;
                    case "ËçâÂéü":
                        this.createGrassland(blocks, sectionMap, biome);
                        break;
                    case "Ëæ≤Êùë":
                        this.createRuralArea(blocks, sectionMap, biome);
                        break;
                }
                
                // ÈÅìË∑ØÁ∂≤„ÇíËøΩÂä†ÔºàÈÉΩÂ∏Ç„Å®Ëæ≤Êùë„ÅÆ„ÅøÔºâ
                if (biome.name === "ÈÉΩÂ∏Ç" || biome.name === "Ëæ≤Êùë") {
                    this.createRoadNetwork(blocks, sectionMap, offsetX, offsetZ, biome);
                }
            }
            
            // ÈÉΩÂ∏Ç„ÅÆÁîüÊàê
            createCityBuildings(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    const blockSize = Math.min(block.width, block.height);
                    
                    // ÂÖ¨Âúí„Åã„Å©„ÅÜ„Åã„ÇíÊ±∫ÂÆö
                    const isPark = Math.random() < this.config.parkChance;
                    
                    if (isPark) {
                        // ÂÖ¨Âúí„Çí‰ΩúÊàê
                        const parkHeight = 0.2;
                        const parkGeometry = new THREE.BoxGeometry(
                            block.width - this.config.roadWidth.main,
                            parkHeight,
                            block.height - this.config.roadWidth.main
                        );
                        const parkMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.park,
                            roughness: 0.8,
                            metalness: 0.1,
                        });
                        const parkMesh = new THREE.Mesh(parkGeometry, parkMaterial);
                        parkMesh.position.set(
                            block.x + block.width / 2,
                            parkHeight / 2,
                            block.y + block.height / 2
                        );
                        parkMesh.receiveShadow = true;
                        sectionMap.add(parkMesh);
                        
                        // ÂÖ¨Âúí„Å´Êú®„ÇíËøΩÂä†
                        this.addTrees(block, parkHeight, sectionMap, biome, 0.5);
                        continue;
                    }
                    
                    // Âª∫Áâ©„ÅÆÈ´ò„Åï„ÇíÊ±∫ÂÆö
                    let height;
                    if (blockSize > this.config.maxBlockSize * 0.7) {
                        height = this.config.buildingHeight.commercial + Math.random() * 2;
                    } else if (block.x % 2 === 0 && block.y % 2 === 0) {
                        height = this.config.buildingHeight.commercial;
                    } else if (blockSize < this.config.minBlockSize * 1.5) {
                        height = this.config.buildingHeight.residential;
                    } else {
                        height = this.config.buildingHeight.min + Math.random() * (this.config.buildingHeight.max - this.config.buildingHeight.min);
                    }
                    
                    // Âª∫Áâ©„ÅÆÁ∏Å„ÇíÂ∞ë„ÅóÂÜÖÂÅ¥„Å´„Åô„ÇãÔºàÈÅìË∑Ø„Çπ„Éö„Éº„ÇπÔºâ
                    const roadOffset = this.config.roadWidth.main;
                    const boxGeometry = new THREE.BoxGeometry(
                        block.width - roadOffset,
                        height,
                        block.height - roadOffset
                    );
                    
                    // Âª∫Áâ©„ÅÆËâ≤„ÇíÊ±∫ÂÆö
                    let blockColor;
                    if (blockSize > this.config.maxBlockSize * 0.7) {
                        blockColor = new THREE.Color(0x555577);
                    } else if (block.x % 2 === 0 && block.y % 2 === 0) {
                        blockColor = new THREE.Color(0x775577);
                    } else if (blockSize < this.config.minBlockSize * 1.5) {
                        blockColor = new THREE.Color(0x775555);
                    } else {
                        blockColor = new THREE.Color(0x555555);
                    }
                    
                    const boxMaterial = new THREE.MeshStandardMaterial({
                        color: blockColor,
                        roughness: 0.7,
                        metalness: 0.3,
                    });
                    const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                    boxMesh.position.set(
                        block.x + block.width / 2,
                        height / 2,
                        block.y + block.height / 2
                    );
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    sectionMap.add(boxMesh);
                }
            }
            
            // Ê£ÆÊûó„ÅÆÁîüÊàê
            createForest(blocks, sectionMap, biome) {
                // Êú®„ÇíÂØÜÈõÜ„Åó„Å¶ÈÖçÁΩÆ
                for (const block of blocks) {
                    const treeSpacing = 5; // Êú®„ÅÆÈñìÈöî„ÇíÁã≠„Åè
                    const treeHeight = 2 + Math.random() * 1; // Êú®„ÅÆÈ´ò„Åï„Çí„É©„É≥„ÉÄ„É†„Å´
                    const treeRadius = 0.5 + Math.random() * 0.3; // Êú®„ÅÆÂ§™„Åï„Çí„É©„É≥„ÉÄ„É†„Å´
                    
                    for (let x = block.x; x < block.x + block.width; x += treeSpacing) {
                        for (let z = block.y; z < block.y + block.height; z += treeSpacing) {
                            // Â∞ë„Åó„É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ„Å´„Åö„Çâ„Åó„Å¶ÈÖçÁΩÆ
                            const offsetX = (Math.random() - 0.5) * treeSpacing;
                            const offsetZ = (Math.random() - 0.5) * treeSpacing;
                            this.createTree(x + offsetX, 0, z + offsetZ, treeHeight, treeRadius, sectionMap, biome);
                        }
                    }
                }
            }
            
            // ËçâÂéü„ÅÆÁîüÊàê
            createGrassland(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    // ‰Ωé„ÅÑÂª∫Áâ©„ÇíÁÇπÂú®„Åï„Åõ„Çã
                    if (Math.random() < 0.3) { // 30%„ÅÆÁ¢∫Áéá„ÅßÂª∫Áâ©„ÇíÁîüÊàê
                        const height = 0.5 + Math.random() * 0.5; // ‰Ωé„ÅÑÂª∫Áâ©
                        const width = 1 + Math.random() * 2;
                        const depth = 1 + Math.random() * 2;
                        
                        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.block,
                            roughness: 0.8,
                            metalness: 0.2,
                        });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(
                            block.x + block.width / 2,
                            height / 2,
                            block.y + block.height / 2
                        );
                        building.castShadow = true;
                        building.receiveShadow = true;
                        sectionMap.add(building);
                    }
                    
                    // Ëçâ„ÇíÁîü„ÇÑ„Åô
                    const grassSpacing = 3;
                    for (let x = block.x; x < block.x + block.width; x += grassSpacing) {
                        for (let z = block.y; z < block.y + block.height; z += grassSpacing) {
                            if (Math.random() < 0.7) { // 70%„ÅÆÁ¢∫Áéá„ÅßËçâ„ÇíÁîü„ÇÑ„Åô
                                this.createGrass(x, 0, z, sectionMap, biome);
                            }
                        }
                    }
                }
            }
            
            // Ëæ≤Êùë„ÅÆÁîüÊàê
            createRuralArea(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    // ‰Ωé„ÅÑÂª∫Áâ©„ÇíÁÇπÂú®„Åï„Åõ„Çã
                    if (Math.random() < 0.4) { // 40%„ÅÆÁ¢∫Áéá„ÅßÂª∫Áâ©„ÇíÁîüÊàê
                        const height = 0.8 + Math.random() * 0.7; // „ÇÑ„ÇÑÈ´ò„ÅÑÂª∫Áâ©
                        const width = 2 + Math.random() * 3;
                        const depth = 2 + Math.random() * 3;
                        
                        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.block,
                            roughness: 0.8,
                            metalness: 0.2,
                        });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(
                            block.x + block.width / 2,
                            height / 2,
                            block.y + block.height / 2
                        );
                        building.castShadow = true;
                        building.receiveShadow = true;
                        sectionMap.add(building);
                    }
                    
                    // Êú®„ÇíÁÇπÂú®„Åï„Åõ„Çã
                    if (Math.random() < 0.2) { // 20%„ÅÆÁ¢∫Áéá„ÅßÊú®„ÇíÁîüÊàê
                        const treeHeight = 1.5 + Math.random() * 0.5;
                        const treeRadius = 0.3;
                        this.createTree(
                            block.x + block.width / 2,
                            0,
                            block.y + block.height / 2,
                            treeHeight,
                            treeRadius,
                            sectionMap,
                            biome
                        );
                    }
                }
            }
            
            // Ëçâ„ÇíÁîüÊàê„Åô„Çã„É°„ÇΩ„ÉÉ„Éâ
            createGrass(x, y, z, sectionMap, biome) {
                const grassHeight = 0.2 + Math.random() * 0.3;
                const grassGeometry = new THREE.CylinderGeometry(0.05, 0.1, grassHeight, 4);
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.ground,
                    roughness: 0.8,
                    metalness: 0.1,
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.position.set(x, y + grassHeight / 2, z);
                grass.rotation.x = Math.random() * 0.2;
                grass.rotation.z = Math.random() * 0.2;
                grass.castShadow = true;
                sectionMap.add(grass);
            }
            
            // ÈÅìË∑ØÁ∂≤„ÇíÁîüÊàê
            createRoadNetwork(blocks, sectionMap, offsetX, offsetZ, biome) {
                // Ê∞¥Âπ≥ÈÅìË∑Ø„Å®ÂûÇÁõ¥ÈÅìË∑Ø„ÅÆ„É™„Çπ„Éà„Çí‰ΩúÊàê
                const horizontalRoads = new Set();
                const verticalRoads = new Set();
                
                // „Åô„Åπ„Å¶„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„Ç®„ÉÉ„Ç∏„ÇíÈÅìË∑Ø„Å®„Åó„Å¶ÁôªÈå≤
                for (const block of blocks) {
                    horizontalRoads.add(block.y);
                    horizontalRoads.add(block.y + block.height);
                    verticalRoads.add(block.x);
                    verticalRoads.add(block.x + block.width);
                }
                
                // ÈÅìË∑Ø„ÅÆÂπÖ„ÇíÊ±∫ÂÆö„Åô„ÇãÈñ¢Êï∞
                const getRoadWidth = (isMainRoad) => {
                    if (isMainRoad) {
                        return this.config.roadWidth.main;
                    }
                    return this.config.roadWidth.min + Math.random() * (this.config.roadWidth.max - this.config.roadWidth.min);
                };
                
                // „É°„Ç§„É≥ÈÅìË∑Ø„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
                const isMainRoad = (position, roads) => {
                    const positions = Array.from(roads);
                    const index = positions.indexOf(position);
                    return index % 2 === 0 && index > 0 && index < positions.length - 1;
                };
                
                // Ê∞¥Âπ≥ÈÅìË∑Ø„ÅÆ‰ΩúÊàê
                for (const y of horizontalRoads) {
                    const roadWidth = getRoadWidth(isMainRoad(y, horizontalRoads));
                    const roadGeometry = new THREE.PlaneGeometry(this.config.width * 1.5, roadWidth * 0.8);
                    const roadMaterial = new THREE.MeshStandardMaterial({
                        color: biome.colors.road,
                        roughness: 0.8,
                        metalness: 0.2,
                    });
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.01, y);
                    road.rotation.x = -Math.PI / 2;
                    sectionMap.add(road);
                }
                
                // ÂûÇÁõ¥ÈÅìË∑Ø„ÅÆ‰ΩúÊàê
                for (const x of verticalRoads) {
                    const roadWidth = getRoadWidth(isMainRoad(x, verticalRoads));
                    const roadGeometry = new THREE.PlaneGeometry(roadWidth * 0.8, this.config.height * 1.5);
                    const roadMaterial = new THREE.MeshStandardMaterial({
                        color: biome.colors.road,
                        roughness: 0.8,
                        metalness: 0.2,
                    });
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(x, 0.01, 0);
                    road.rotation.x = -Math.PI / 2;
                    sectionMap.add(road);
                }
            }
            
            // 1Êú¨„ÅÆÊú®„Çí‰ΩúÊàê„Åô„Çã„É°„ÇΩ„ÉÉ„Éâ
            createTree(x, y, z, treeHeight, treeRadius, sectionMap, biome) {
                // Êú®„ÅÆÂππ
                const trunkGeometry = new THREE.CylinderGeometry(treeRadius * 0.06, treeRadius * 0.09, treeHeight * 0.09, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1,
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, y + treeHeight * 0.045, z);
                trunk.castShadow = true;
                sectionMap.add(trunk);
                
                // Êú®„ÅÆËëâ
                const leavesGeometry = new THREE.ConeGeometry(treeRadius * 0.3, treeHeight * 0.21, 8);
                const leavesMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.tree,
                    roughness: 0.8,
                    metalness: 0.1,
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, y + treeHeight * 0.15, z);
                leaves.castShadow = true;
                sectionMap.add(leaves);
            }
            
            // ÂÖ¨Âúí„Å´Êú®„ÇíËøΩÂä†„Åô„Çã„É°„ÇΩ„ÉÉ„Éâ
            addTrees(block, baseHeight, sectionMap, biome, treeSpacing) {
                const treeHeight = 0.45;  // 1.5„Åã„Çâ0.45„Å´Á∏ÆÂ∞è
                const treeRadius = 0.09;  // 0.3„Åã„Çâ0.09„Å´Á∏ÆÂ∞è
                
                for (let x = block.x + treeSpacing; x < block.x + block.width - treeSpacing; x += treeSpacing) {
                    for (let z = block.y + treeSpacing; z < block.y + block.height - treeSpacing; z += treeSpacing) {
                        this.createTree(x, baseHeight, z, treeHeight, treeRadius, sectionMap, biome);
                    }
                }
            }
            
            // „Éû„ÉÉ„Éó„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            clear() {
                scene.remove(this.meshes);
                this.blocks = [];
                this.meshes = new THREE.Group();
                this.buildOutline = new THREE.Group();
                this.roadNetwork = new THREE.Group();
                this.mapSections.clear();
            }
        }
        
        // „Ç¢„Ç§„ÉÜ„É†„ÇØ„É©„Çπ
        class Item {
            constructor(type, position) {
                this.type = type;
                this.position = position;
                this.mesh = null;
                this.isCollected = false;
                
                // „Ç¢„Ç§„ÉÜ„É†„ÅÆÂäπÊûú„ÇíÂÆöÁæ©
                this.effects = {
                    '„Ç∑„É™„Ç¢„É´': { hunger: 30 },
                    '„ÇØ„É©„ÉÉ„Ç´„Éº': { hunger: 20 },
                    'Áº∂Ë©∞': { hunger: 40 },
                    '„Çä„Çì„Åî': { hunger: 15 },
                    '„Éà„Éû„Éà': { hunger: 10 },
                    '„Åã„Åº„Å°„ÇÉ': { hunger: 25 },
                    '„Éö„ÉÉ„Éà„Éú„Éà„É´„ÅÆÊ∞¥': { thirst: 50 },
                    'ÂåÖÂ∏Ø': { bleeding: 50 },
                    'T„Ç∑„É£„ÉÑ': { temperature: 20 },
                    '„Ç∏„Éº„Éë„É≥': { temperature: 15 }
                };
            }
            
            createMesh() {
                // „Ç¢„Ç§„ÉÜ„É†„ÅÆË¶ã„ÅüÁõÆ„ÇíË®≠ÂÆö
                const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
                const material = new THREE.MeshStandardMaterial({ 
                    color: this.getColor(),
                    emissive: this.getColor(),
                    emissiveIntensity: 0.5
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.position.y = 0.18; // Âú∞Èù¢„Åã„ÇâÂ∞ë„ÅóÊµÆ„Åã„Åõ„Çã
                this.mesh.castShadow = true;
                
                // ÂõûËª¢„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.rotation.y = Math.random() * Math.PI * 2;
                this.rotationSpeed = 0.01;
            }
            
            update() {
                if (this.mesh) {
                    this.mesh.rotation.y += this.rotationSpeed;
                    //this.mesh.position.y = 0.01 + Math.sin(Date.now() * 0.003) * 0.005;
                }
            }
            
            getColor() {
                const colors = {
                    '„Ç∑„É™„Ç¢„É´': 0xffd700,
                    '„ÇØ„É©„ÉÉ„Ç´„Éº': 0xffa500,
                    'Áº∂Ë©∞': 0xc0c0c0,
                    '„Çä„Çì„Åî': 0xff0000,
                    '„Éà„Éû„Éà': 0xff6347,
                    '„Åã„Åº„Å°„ÇÉ': 0xffa500,
                    '„Éö„ÉÉ„Éà„Éú„Éà„É´„ÅÆÊ∞¥': 0x00ffff,
                    'ÂåÖÂ∏Ø': 0xffffff,
                    'T„Ç∑„É£„ÉÑ': 0x4169e1,
                    '„Ç∏„Éº„Éë„É≥': 0x000080
                };
                return colors[this.type] || 0xffffff;
            }
            
            collect() {
                if (!this.isCollected) {
                    this.isCollected = true;
                    if (this.mesh) {
                        scene.remove(this.mesh);
                    }
                    return true;
                }
                return false;
            }
            
            applyEffect(playerStatus) {
                const effect = this.effects[this.type];
                if (effect) {
                    for (const [stat, value] of Object.entries(effect)) {
                        if (stat === 'temperature') {
                            // ‰ΩìÊ∏©Ê∏õÂ∞ëÁéá„Çí‰∏ã„Åí„Çã
                            playerStatus.decreaseRates.temperature *= 0.5;
                        } else {
                            // „Åù„ÅÆ‰ªñ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂõûÂæ©
                            playerStatus[stat] = Math.min(100, playerStatus[stat] + value);
                        }
                    }
                    playerStatus.updateUI();
                }
            }
        }
        
        // „Ç¢„Ç§„ÉÜ„É†„Éû„Éç„Éº„Ç∏„É£„Éº„ÇØ„É©„Çπ
        class ItemManager {
            constructor(scene) {
                this.scene = scene;
                this.items = new Set();
                this.spawnRadius = 10;
                this.despawnRadius = 10;
                this.maxItems = 100; // ÊúÄÂ§ß„Ç¢„Ç§„ÉÜ„É†Êï∞„Çí100„Å´Ë®≠ÂÆö
                this.itemTypes = [
                    '„Ç∑„É™„Ç¢„É´', '„ÇØ„É©„ÉÉ„Ç´„Éº', 'Áº∂Ë©∞', '„Çä„Çì„Åî', '„Éà„Éû„Éà',
                    '„Åã„Åº„Å°„ÇÉ', '„Éö„ÉÉ„Éà„Éú„Éà„É´„ÅÆÊ∞¥', 'ÂåÖÂ∏Ø', 'T„Ç∑„É£„ÉÑ', '„Ç∏„Éº„Éë„É≥'
                ];
            }
            
            // „Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞Âá¶ÁêÜ„Çí‰øÆÊ≠£
            update(playerPosition) {
                // „Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞„Å®ÁÆ°ÁêÜ
                for (const item of this.items) {
                    if (item.mesh) {
                        item.update();
                    }
                }
            }
            
            spawnItems(playerPosition) {
                // „Éó„É¨„Ç§„É§„Éº„ÅÆÂë®Âõ≤„Å´„Ç¢„Ç§„ÉÜ„É†„ÇíÁîüÊàê
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * this.spawnRadius;
                    const position = new THREE.Vector3(
                        playerPosition.x + Math.cos(angle) * distance,
                        1,
                        playerPosition.z + Math.sin(angle) * distance
                    );
                    
                    const type = this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)];
                    const item = new Item(type, position);
                    item.createMesh();
                    this.scene.add(item.mesh);
                    this.items.add(item);
                }
            }
            
            checkCollisions(playerPosition) {
                for (const item of this.items) {
                    if (item.mesh) {
                        const distance = item.mesh.position.distanceTo(playerPosition);
                        if (distance < 2.0) { // ÂèñÂæóË∑ùÈõ¢„Çí2.0„Å´Êã°Â§ß
                            if (item.collect()) {
                                this.items.delete(item);
                                return item;
                            }
                        }
                    }
                }
                return null;
            }
        }
        
        // „Ç§„É≥„Éô„É≥„Éà„É™„ÇØ„É©„Çπ
        class Inventory {
            constructor() {
                this.items = [];
                this.maxItems = 100;
                this.panel = document.getElementById('inventory-panel');
                this.list = document.getElementById('inventory-list');
                this.isOpen = false;
                

            }
            
            addItem(item) {
                if (this.items.length < this.maxItems) {
                    this.items.push(item);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            removeItem(index) {
                if (index >= 0 && index < this.items.length) {
                    this.items.splice(index, 1);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            useItem(index, playerStatus) {
                if (index >= 0 && index < this.items.length) {
                    const item = this.items[index];
                    item.applyEffect(playerStatus);
                    this.removeItem(index);
                    return true;
                }
                return false;
            }
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panel.style.display = this.isOpen ? 'block' : 'none';
                if (this.isOpen) {
                    this.updateUI();
                }
            }
            
            updateUI() {
                this.list.innerHTML = '';
                
                // „Éò„ÉÉ„ÉÄ„ÉºË°å
                const header = document.createElement('div');
                header.className = 'inventory-item';
                header.innerHTML = `
                    <div>ÂêçÂâç</div>
                    <div>È£ü„Åπ„Çã</div>
                    <div>Ë£ÖÂÇô„Åô„Çã</div>
                    <div>ÁµÑ„ÅøÂêà„Çè„Åõ„Çã</div>
                    <div>Êç®„Å¶„Çã</div>
                `;
                this.list.appendChild(header);
                
                // „Ç¢„Ç§„ÉÜ„É†Ë°å
                this.items.forEach((item, index) => {
                    const row = document.createElement('div');
                    row.className = 'inventory-item';
                    row.innerHTML = `
                        <div>${item.type}</div>
                        <button onclick="inventory.useItem(${index}, characterController.status)">È£ü„Åπ„Çã</button>
                        <button onclick="inventory.useItem(${index}, characterController.status)">Ë£ÖÂÇô„Åô„Çã</button>
                        <button disabled>ÁµÑ„ÅøÂêà„Çè„Åõ„Çã</button>
                        <button onclick="inventory.removeItem(${index})">Êç®„Å¶„Çã</button>
                    `;
                    this.list.appendChild(row);
                });
            }
        }
        
        // „Ç¢„Ç§„ÉÜ„É†„Éû„Éç„Éº„Ç∏„É£„Éº„Å®„Ç§„É≥„Éô„É≥„Éà„É™„ÅÆÂàùÊúüÂåñ
        const itemManager = new ItemManager(scene);
        const inventory = new Inventory();
        
        // „Ç≠„É£„É©„ÇØ„Çø„ÉºÂà∂Âæ°„ÇØ„É©„Çπ
        class CharacterController {
            constructor(scene, camera, topDownCamera) {
                this.scene = scene;
                this.camera = camera;
                this.topDownCamera = topDownCamera;
                this.currentCamera = camera;
                this.moveSpeed = 0.01;
                this.rotationSpeed = 0.03;
                this.jumpForce = 0.5;
                this.gravity = 0.015;
                this.velocity = new THREE.Vector3();
                this.isJumping = false;
                this.isGrounded = false;
                this.raycaster = new THREE.Raycaster();
                this.collisionDistance = 0.1;
                
                // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆÁä∂ÊÖã
                this.joystick = {
                    active: false,
                    position: new THREE.Vector2(),
                    startPosition: new THREE.Vector2(),
                    currentPosition: new THREE.Vector2(),
                    element: document.getElementById('joystick'),
                    knob: document.getElementById('joystick-knob')
                };
                
                // „Ç≤„Éº„É†„Éë„ÉÉ„Éâ„ÅÆÁä∂ÊÖã
                this.gamepad = null;
                this.gamepadConnected = false;
                
                // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ‰ΩúÊàê
                this.createCharacter();
                
                // ÂÖ•ÂäõÁä∂ÊÖã
                this.keys = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    jump: false
                };
                
                // „Éû„Ç¶„ÇπÂà∂Âæ°
                this.mouseSensitivity = 0.002;
                this.mouseX = 0;
                this.mouseY = 0;
                
                // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅÆË®≠ÂÆö
                this.setupEventListeners();
                
                // „Éó„É¨„Ç§„É§„Éº„Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆÂàùÊúüÂåñ
                this.status = new PlayerStatus();
                this.isMoving = false;
                
                // Â∞ÑÊíÉÈñ¢ÈÄ£„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£
                this.bullets = [];
                this.isAiming = false;
                this.lastShotTime = 0;
                this.shootCooldown = 500; // 0.5Áßí„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
                
                // ÁÖßÊ∫ñ„ÅÆË°®Á§∫/ÈùûË°®Á§∫
                this.crosshair = document.getElementById('crosshair');
            }
            
            createCharacter() {
                // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ„Ç∞„É´„Éº„Éó
                this.character = new THREE.Group();
                
                // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ‰Ωì
                const bodyGeometry = new THREE.BoxGeometry(0.012, 0.024, 0.012);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 0.012;
                this.character.add(this.body);
                
                // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÈ†≠
                const headGeometry = new THREE.BoxGeometry(0.008, 0.008, 0.008);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.028;
                this.character.add(this.head);
                
                // ËÖï
                const armGeometry = new THREE.BoxGeometry(0.003, 0.012, 0.003);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                
                this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
                this.leftArm.position.set(-0.008, 0.012, 0);
                this.character.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
                this.rightArm.position.set(0.008, 0.012, 0);
                this.character.add(this.rightArm);
                
                // ÂΩ±„ÇíËêΩ„Å®„Åô
                this.character.traverse((object) => {
                    if (object instanceof THREE.Mesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                
                this.scene.add(this.character);
                this.character.position.set(0, 0, 0);
            }
            
            setupEventListeners() {
                // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // „Çø„ÉÉ„ÉÅÂÖ•Âäõ
                this.joystick.element.addEventListener('touchstart', (e) => this.onJoystickStart(e));
                this.joystick.element.addEventListener('touchmove', (e) => this.onJoystickMove(e));
                this.joystick.element.addEventListener('touchend', () => this.onJoystickEnd());
                
                // ÊîªÊíÉ„Éú„Çø„É≥
                document.getElementById('attack-button').addEventListener('touchstart', () => {
                    this.shoot();
                });
                
                // „Ç∏„É£„É≥„Éó„Éú„Çø„É≥
                document.getElementById('jump-button').addEventListener('touchstart', () => {
                    this.keys.jump = true;
                });
                document.getElementById('jump-button').addEventListener('touchend', () => {
                    this.keys.jump = false;
                });
                
                // „Éê„ÉÉ„Ç∞„Éú„Çø„É≥
                document.getElementById('bag-button').addEventListener('click', () => {
                    inventory.toggle();
                });
                
                // „Ç´„É°„É©Âàá„ÇäÊõø„Åà„Éú„Çø„É≥
                document.getElementById('camera-button').addEventListener('click', () => {
                    this.currentCamera = this.currentCamera === this.camera ? this.topDownCamera : this.camera;
                });
                
                // „Ç≤„Éº„É†„Éë„ÉÉ„ÉâÊé•Á∂ö„Ç§„Éô„É≥„Éà
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad);
                    this.gamepad = e.gamepad;
                    this.gamepadConnected = true;
                });
                
                window.addEventListener('gamepaddisconnected', () => {
                    console.log('Gamepad disconnected');
                    this.gamepad = null;
                    this.gamepadConnected = false;
                });
            }
            
            onJoystickStart(event) {
                event.preventDefault();
                const touch = event.touches[0];
                const rect = this.joystick.element.getBoundingClientRect();
                
                this.joystick.active = true;
                this.joystick.startPosition.set(
                    touch.clientX - rect.left - rect.width / 2,
                    touch.clientY - rect.top - rect.height / 2
                );
                this.joystick.currentPosition.copy(this.joystick.startPosition);
                this.updateJoystickPosition();
            }
            
            onJoystickMove(event) {
                if (!this.joystick.active) return;
                event.preventDefault();
                
                const touch = event.touches[0];
                const rect = this.joystick.element.getBoundingClientRect();
                
                this.joystick.currentPosition.set(
                    touch.clientX - rect.left - rect.width / 2,
                    touch.clientY - rect.top - rect.height / 2
                );
                
                // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆÁØÑÂõ≤„ÇíÂà∂Èôê
                const distance = this.joystick.currentPosition.length();
                const maxDistance = rect.width / 2 - 25; // „Éé„Éñ„ÅÆÂçäÂæÑ„ÇíËÄÉÊÖÆ
                if (distance > maxDistance) {
                    this.joystick.currentPosition.normalize().multiplyScalar(maxDistance);
                }
                
                this.updateJoystickPosition();
            }
            
            onJoystickEnd() {
                this.joystick.active = false;
                this.joystick.currentPosition.set(0, 0);
                this.updateJoystickPosition();
            }
            
            updateJoystickPosition() {
                const knob = this.joystick.knob;
                const x = this.joystick.currentPosition.x;
                const y = this.joystick.currentPosition.y;
                knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
            }
            
            onKeyDown(event) {
                switch(event.code) {
                    case 'KeyW': this.keys.forward = true; break;
                    case 'KeyS': this.keys.backward = true; break;
                    case 'KeyA': this.keys.left = true; break;
                    case 'KeyD': this.keys.right = true; break;
                    case 'Space': 
                        this.keys.jump = true;
                        this.shoot(); // „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÂ∞ÑÊíÉ
                        break;
                }
            }
            
            onKeyUp(event) {
                switch(event.code) {
                    case 'KeyW': this.keys.forward = false; break;
                    case 'KeyS': this.keys.backward = false; break;
                    case 'KeyA': this.keys.left = false; break;
                    case 'KeyD': this.keys.right = false; break;
                    case 'Space': this.keys.jump = false; break;
                }
            }
            
            update() {
                // „Ç≤„Éº„É†„Éë„ÉÉ„Éâ„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
                if (this.gamepadConnected) {
                    const gamepads = navigator.getGamepads();
                    this.gamepad = gamepads[this.gamepad.index];
                    
                    // Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆÂÖ•Âäõ
                    const leftStickX = this.gamepad.axes[0];
                    const leftStickY = this.gamepad.axes[1];
                    
                    // „Éá„ÉÉ„Éâ„Çæ„Éº„É≥ÔºàÂ∞è„Åï„Å™ÂÖ•Âäõ„ÇíÁÑ°Ë¶ñÔºâ
                    const deadzone = 0.1;
                    if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                        this.joystick.currentPosition.x = leftStickX * 75;
                        this.joystick.currentPosition.y = leftStickY * 75;
                        this.joystick.active = true;
                    } else {
                        this.joystick.active = false;
                        this.joystick.currentPosition.set(0, 0);
                    }
                    
                    // A„Éú„Çø„É≥Ôºà„Ç∏„É£„É≥„ÉóÔºâ
                    this.keys.jump = this.gamepad.buttons[0].pressed;
                    
                    // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                    this.updateJoystickPosition();
                }
                
                // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÂõûËª¢ÔºàÂõ∫ÂÆöÔºâ
                this.character.rotation.y = 0;
                
                // ÁßªÂãïÊñπÂêë„ÅÆË®àÁÆó
                const moveDirection = new THREE.Vector3();
                
                if (this.joystick.active) {
                    // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆÂÖ•Âäõ„Çí‰ΩøÁî®
                    moveDirection.x = this.joystick.currentPosition.x / 75;
                    moveDirection.z = this.joystick.currentPosition.y / 75;
                } else {
                    // „Ç≠„Éº„Éú„Éº„Éâ„ÅÆÂÖ•Âäõ„Çí‰ΩøÁî®
                    if (this.keys.forward) moveDirection.z -= 1;
                    if (this.keys.backward) moveDirection.z += 1;
                    if (this.keys.left) moveDirection.x -= 1;
                    if (this.keys.right) moveDirection.x += 1;
                }
                
                // ÁßªÂãïÊñπÂêë„Çí„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÂêë„Åç„Å´Âêà„Çè„Åõ„Å¶ÂõûËª¢ÔºàÂõ∫ÂÆöÊñπÂêëÔºâ
                moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
                
                // ÈáçÂäõ„ÅÆÈÅ©Áî®
                this.velocity.y -= this.gravity;
                
                // Âú∞Èù¢„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                this.raycaster.set(
                    this.character.position.clone().add(new THREE.Vector3(0, 0.1, 0)),
                    new THREE.Vector3(0, -1, 0)
                );
                const groundIntersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Âú∞Èù¢„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºàÂú∞Èù¢„ÅÆ„Åø„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºâ
                const groundCheck = groundIntersects.find(obj => 
                    obj.object.geometry.type === 'PlaneGeometry'
                );
                
                if (groundCheck && groundCheck.distance < 0.2) {
                    this.isGrounded = true;
                    this.velocity.y = Math.max(0, this.velocity.y);
                    this.character.position.y = groundCheck.point.y;
                } else {
                    this.isGrounded = false;
                }
                
                // ÁßªÂãï„ÅÆÈÅ©Áî®ÔºàË°ùÁ™ÅÂà§ÂÆö‰ªò„ÅçÔºâ
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    const newPosition = this.character.position.clone().add(
                        moveDirection.multiplyScalar(this.moveSpeed)
                    );
                    
                    // ÁßªÂãïÂâç„Å´Ë°ùÁ™Å„ÉÅ„Çß„ÉÉ„ÇØ
                    const canMove = !this.checkCollision(
                        newPosition.clone().add(new THREE.Vector3(0, 0.1, 0)),
                        moveDirection
                    );
                    
                    if (canMove) {
                        this.character.position.x = newPosition.x;
                        this.character.position.z = newPosition.z;
                        
                        // Ê≠©Ë°å„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                        const walkCycle = Date.now() * 0.01;
                        this.leftArm.rotation.x = Math.sin(walkCycle) * 0.5;
                        this.rightArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
                    }
                } else {
                    // ÈùôÊ≠¢ÊôÇ„ÅØËÖï„ÇíÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´
                    this.leftArm.rotation.x = 0;
                    this.rightArm.rotation.x = 0;
                }
                
                // ÂûÇÁõ¥ÊñπÂêë„ÅÆÁßªÂãïÔºàÈáçÂäõ„Å®„Ç∏„É£„É≥„ÉóÔºâ
                if (!this.isGrounded) {
                    this.character.position.y += this.velocity.y;
                }
                
                // „Ç∏„É£„É≥„ÉóÂá¶ÁêÜ
                if (this.keys.jump && this.isGrounded) {
                    this.velocity.y = this.jumpForce;
                    this.isGrounded = false;
                }
                
                // „Ç´„É°„É©„ÅÆ‰ΩçÁΩÆ„Å®ÂõûËª¢„ÅÆÊõ¥Êñ∞
                if (this.currentCamera === this.camera) {
                    // ÈÄöÂ∏∏„ÅÆTPS„Ç´„É°„É©
                    const cameraOffset = new THREE.Vector3(0, 0.1, 0.3);
                    this.camera.position.copy(this.character.position).add(cameraOffset);
                    this.camera.lookAt(this.character.position);
                } else {
                    // Êñú„ÇÅ‰∏ä„Åã„Çâ„ÅÆË¶ã‰∏ã„Çç„Åó„Ç´„É°„É©
                    this.topDownCamera.position.copy(this.character.position).add(new THREE.Vector3(0, 1, 1));
                    this.topDownCamera.lookAt(this.character.position);
                }
                
                // ÁßªÂãïÁä∂ÊÖã„ÅÆÊõ¥Êñ∞
                this.isMoving = moveDirection.length() > 0;
                
                // ÁèæÂú®„ÅÆ„Éê„Ç§„Ç™„Éº„É†„ÇíÂèñÂæó
                const currentBiome = cityMap.getBiome(this.character.position.x, this.character.position.z);
                
                // „Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆÊõ¥Êñ∞
                this.status.update(this.isMoving, currentBiome);
                
                // Âºæ‰∏∏„ÅÆÊõ¥Êñ∞
                this.bullets = this.bullets.filter(bullet => !bullet.update());
                
                // ÁÖßÊ∫ñ„É¢„Éº„Éâ‰∏≠„ÅØÁßªÂãïÈÄüÂ∫¶„Çí‰∏ã„Åí„Çã
                if (this.isAiming) {
                    this.moveSpeed = 0.005; // ÈÄöÂ∏∏„ÅÆÂçäÂàÜ
                } else {
                    this.moveSpeed = 0.01;
                }
                
                // „Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞
                itemManager.update(this.character.position);
                
                // „Ç¢„Ç§„ÉÜ„É†„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                const collectedItem = itemManager.checkCollisions(this.character.position);
                if (collectedItem) {
                    inventory.addItem(collectedItem);
                }
            }
            
            // Ë°ùÁ™ÅÂà§ÂÆö„ÇíË°å„ÅÜ„É°„ÇΩ„ÉÉ„Éâ
            checkCollision(position, direction) {
                this.raycaster.set(position, direction);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // Âª∫Áâ©„Å®Âú∞Èù¢„ÅÆ„Åø„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                const validObjects = intersects.filter(obj => 
                    obj.object.type === 'Mesh' && 
                    (obj.object.geometry.type === 'BoxGeometry' || 
                     obj.object.geometry.type === 'PlaneGeometry')
                );
                
                if (validObjects.length > 0 && validObjects[0].distance < this.collisionDistance) {
                    return true;
                }
                return false;
            }
            
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime < this.shootCooldown) return;
                
                this.lastShotTime = currentTime;
                
                // Âºæ‰∏∏„ÅÆÁîüÊàê‰ΩçÁΩÆÔºà„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÊ≠£Èù¢Ôºâ
                const bulletPosition = this.character.position.clone();
                bulletPosition.y += 0.02; // Â∞ë„Åó‰∏ä„Å´Ë™øÊï¥
                
                // Áô∫Â∞ÑÊñπÂêëÔºà„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÂêë„ÅçÔºâ
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.character.quaternion);
                
                // Âºæ‰∏∏„ÇíÁîüÊàê
                const bullet = new Bullet(this.scene, bulletPosition, direction);
                this.bullets.push(bullet);
            }
        }
        
        // „Çæ„É≥„Éì„ÇØ„É©„Çπ
        class Zombie {
            constructor(scene, position) {
                this.scene = scene;
                this.speed = 0.03;  // ÈÄüÂ∫¶„Çí0.03„Åã„Çâ0.01„Å´Ê∏õÂ∞ë
                this.detectionRadius = 10;
                this.attackRadius = 1;
                this.health = 100;
                this.state = 'wander'; // wander, chase
                this.wanderDirection = new THREE.Vector3();
                this.wanderTimer = 0;
                this.wanderInterval = 2000; // 2Áßí„Åî„Å®„Å´ÊñπÂêëËª¢Êèõ
                this.lastWanderTime = Date.now();
                this.isDead = false;
                
                // „Çæ„É≥„Éì„ÅÆ„É°„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê
                this.createMesh();
                this.mesh.position.copy(position);
                scene.add(this.mesh);
            }
            
            createMesh() {
                this.mesh = new THREE.Group();
                
                // ‰Ωì
                const bodyGeometry = new THREE.BoxGeometry(0.012, 0.024, 0.012);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 0.012;
                this.mesh.add(this.body);
                
                // È†≠
                const headGeometry = new THREE.BoxGeometry(0.008, 0.008, 0.008);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0x999999 });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.028;
                this.mesh.add(this.head);
                
                // ËÖï
                const armGeometry = new THREE.BoxGeometry(0.003, 0.012, 0.003);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                
                this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
                this.leftArm.position.set(-0.008, 0.012, 0);
                this.mesh.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
                this.rightArm.position.set(0.008, 0.012, 0);
                this.mesh.add(this.rightArm);
                
                // ÂΩ±„ÇíËêΩ„Å®„Åô
                this.mesh.traverse((object) => {
                    if (object instanceof THREE.Mesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
            }
            
            update(playerPosition) {
                const distanceToPlayer = this.mesh.position.distanceTo(playerPosition);
                
                if (distanceToPlayer < this.attackRadius) {
                    // „Éó„É¨„Ç§„É§„Éº„Å´„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã
                    characterController.status.takeDamage(1);
                }
                
                // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆË∑ùÈõ¢„Å´Âøú„Åò„Å¶Áä∂ÊÖã„ÇíÊõ¥Êñ∞
                if (distanceToPlayer < this.detectionRadius) {
                    this.state = 'chase';
                } else {
                    this.state = 'wander';
                }
                
                // Áä∂ÊÖã„Å´Âøú„Åò„ÅüË°åÂãï
                if (this.state === 'chase') {
                    // „Éó„É¨„Ç§„É§„Éº„ÇíËøΩ„ÅÑ„Åã„Åë„Çã
                    const direction = new THREE.Vector3()
                        .subVectors(playerPosition, this.mesh.position)
                        .normalize();
                    
                    // ÁßªÂãïÂâç„ÅÆ‰ΩçÁΩÆ„Çí‰øùÂ≠ò
                    const oldPosition = this.mesh.position.clone();
                    
                    // ÁßªÂãï„ÇíË©¶„Åø„Çã
                    this.mesh.position.add(direction.multiplyScalar(this.speed));
                    
                    // Ë°ùÁ™ÅÂà§ÂÆö
                    if (this.checkCollision()) {
                        // Ë°ùÁ™Å„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´Êàª„Åô
                        this.mesh.position.copy(oldPosition);
                    }
                    
                    this.mesh.lookAt(playerPosition);
                    
                    // ËÖï„ÇíÊåØ„Çã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                    this.leftArm.rotation.x = Math.sin(Date.now() * 0.01) * 0.5;
                    this.rightArm.rotation.x = Math.sin(Date.now() * 0.01 + Math.PI) * 0.5;
                } else {
                    // „É©„É≥„ÉÄ„É†„Å´ÂæòÂæä
                    if (Date.now() - this.lastWanderTime > this.wanderInterval) {
                        this.wanderDirection.set(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                        this.lastWanderTime = Date.now();
                    }
                    
                    // ÁßªÂãïÂâç„ÅÆ‰ΩçÁΩÆ„Çí‰øùÂ≠ò
                    const oldPosition = this.mesh.position.clone();
                    
                    // ÁßªÂãï„ÇíË©¶„Åø„Çã
                    this.mesh.position.add(this.wanderDirection.multiplyScalar(this.speed * 0.5));
                    
                    // Ë°ùÁ™ÅÂà§ÂÆö
                    if (this.checkCollision()) {
                        // Ë°ùÁ™Å„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´Êàª„Åô
                        this.mesh.position.copy(oldPosition);
                        // Êñ∞„Åó„ÅÑÊñπÂêë„ÇíË®≠ÂÆö
                        this.wanderDirection.set(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                    }
                    
                    this.mesh.lookAt(
                        this.mesh.position.clone().add(this.wanderDirection)
                    );
                    
                    // ËÖï„ÇíÂ∞ë„ÅóÂãï„Åã„Åô
                    this.leftArm.rotation.x = Math.sin(Date.now() * 0.005) * 0.2;
                    this.rightArm.rotation.x = Math.sin(Date.now() * 0.005 + Math.PI) * 0.2;
                }
            }
            
            // Ë°ùÁ™ÅÂà§ÂÆöÔºàÊúÄÈÅ©ÂåñÁâàÔºâ
            checkCollision() {
                const raycaster = new THREE.Raycaster();
                const directions = [
                    new THREE.Vector3(1, 0, 0),   // Âè≥
                    new THREE.Vector3(-1, 0, 0),  // Â∑¶
                    new THREE.Vector3(0, 0, 1),   // Ââç
                    new THREE.Vector3(0, 0, -1)   // Âæå
                ];
                
                // Ëøë„Åè„ÅÆÂª∫Áâ©„ÅÆ„Åø„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(this.mesh.position);
                        return distance < 3; // 3Âçò‰Ωç‰ª•ÂÜÖ„ÅÆÂª∫Áâ©„ÅÆ„Åø„ÉÅ„Çß„ÉÉ„ÇØ
                    }
                    return false;
                });
                
                for (const direction of directions) {
                    raycaster.set(this.mesh.position, direction);
                    const intersects = raycaster.intersectObjects(nearbyObjects, true);
                    
                    for (const intersect of intersects) {
                        if (intersect.object.geometry.type === 'BoxGeometry' && 
                            intersect.distance < 0.1) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            remove() {
                this.scene.remove(this.mesh);
            }
            
            takeDamage() {
                if (!this.isDead) {
                    this.isDead = true;
                    this.remove();
                }
            }
        }
        
        // Âºæ‰∏∏„ÇØ„É©„Çπ
        class Bullet {
            constructor(scene, position, direction) {
                this.scene = scene;
                this.speed = 0.5;
                this.lifetime = 2000; // 2ÁßíÂæå„Å´Ê∂àÊªÖ
                this.createdAt = Date.now();
                
                // Âºæ‰∏∏„ÅÆ„É°„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê
                const geometry = new THREE.SphereGeometry(0.005, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.castShadow = true;
                
                // ÁßªÂãïÊñπÂêë„ÇíË®≠ÂÆö
                this.direction = direction.normalize();
                
                scene.add(this.mesh);
            }
            
            update() {
                // Âºæ‰∏∏„ÇíÁßªÂãï
                this.mesh.position.add(this.direction.multiplyScalar(this.speed));
                
                // ÂØøÂëΩ„ÅåÂ∞Ω„Åç„Åü„ÇâÂâäÈô§
                if (Date.now() - this.createdAt > this.lifetime) {
                    this.remove();
                    return true;
                }
                return false;
            }
            
            remove() {
                this.scene.remove(this.mesh);
            }
        }
        
        // „Çæ„É≥„Éì„Éû„Éç„Éº„Ç∏„É£„Éº„ÇØ„É©„Çπ
        class ZombieManager {
            constructor(scene) {
                this.scene = scene;
                this.zombies = new Set();
                this.spawnRadius = 2;
                this.despawnRadius = 3;
                this.maxZombies =  1;
                this.spawnInterval = 5000; // 5Áßí„Åî„Å®„Å´„Çπ„Éù„Éº„É≥
                this.lastSpawnTime = Date.now();
                this.currentZombieIndex = 0; // ÁèæÂú®Âá¶ÁêÜ‰∏≠„ÅÆ„Çæ„É≥„Éì„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
                this.zombiesArray = []; // „Çæ„É≥„Éì„ÅÆÈÖçÂàóÔºàÈ†ÜÊ¨°Âá¶ÁêÜÁî®Ôºâ
            }
            
            update(playerPosition) {
                // „Çæ„É≥„Éì„ÅÆÈÖçÂàó„ÇíÊõ¥Êñ∞ÔºàSet„Åã„ÇâÈÖçÂàó„Å∏Ôºâ
                this.zombiesArray = Array.from(this.zombies);
                
                // 1„Éï„É¨„Éº„É†„ÅßÂá¶ÁêÜ„Åô„Çã„Çæ„É≥„Éì„ÅÆÊï∞ÔºàÂÖ®‰Ωì„ÅÆ1/4„ÇíÂá¶ÁêÜÔºâ
                const zombiesPerFrame = Math.max(1, Math.ceil(this.zombiesArray.length / 4));
                
                // ÁèæÂú®„ÅÆ„Éï„É¨„Éº„É†„ÅßÂá¶ÁêÜ„Åô„Çã„Çæ„É≥„Éì„ÅÆÁØÑÂõ≤„ÇíË®àÁÆó
                const startIndex = this.currentZombieIndex;
                const endIndex = Math.min(startIndex + zombiesPerFrame, this.zombiesArray.length);
                
                // ÊåáÂÆöÁØÑÂõ≤„ÅÆ„Çæ„É≥„Éì„ÇíÂá¶ÁêÜ
                for (let i = startIndex; i < endIndex; i++) {
                    const zombie = this.zombiesArray[i];
                    const distanceToPlayer = zombie.mesh.position.distanceTo(playerPosition);
                    
                    if (distanceToPlayer > this.despawnRadius) {
                        zombie.remove();
                        this.zombies.delete(zombie);
                    } else {
                        zombie.update(playerPosition);
                    }
                }
                
                // Ê¨°„ÅÆ„Éï„É¨„Éº„É†„ÅÆÈñãÂßã„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÊõ¥Êñ∞
                this.currentZombieIndex = endIndex >= this.zombiesArray.length ? 0 : endIndex;
            }
            
            spawnZombie(playerPosition) {
                // „Éó„É¨„Ç§„É§„Éº„Åã„Çâ‰∏ÄÂÆöË∑ùÈõ¢Èõ¢„Çå„Åü‰ΩçÁΩÆ„Å´„Çπ„Éù„Éº„É≥
                const angle = Math.random() * Math.PI * 2;
                const spawnPosition = new THREE.Vector3(
                    playerPosition.x + Math.cos(angle) * this.spawnRadius,
                    0.1,
                    playerPosition.z + Math.sin(angle) * this.spawnRadius
                );
                
                // „Çπ„Éù„Éº„É≥‰ΩçÁΩÆ„ÅåÈöúÂÆ≥Áâ©„Å®Èáç„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç
                if (!this.checkSpawnCollision(spawnPosition)) {
                    const zombie = new Zombie(this.scene, spawnPosition);
                    this.zombies.add(zombie);
                }
            }
            
            // „Çπ„Éù„Éº„É≥‰ΩçÁΩÆ„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºàÊúÄÈÅ©ÂåñÁâàÔºâ
            checkSpawnCollision(position) {
                const raycaster = new THREE.Raycaster();
                raycaster.set(position, new THREE.Vector3(0, -1, 0));
                
                // Ëøë„Åè„ÅÆÂª∫Áâ©„ÅÆ„Åø„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(position);
                        return distance < 5; // 5Âçò‰Ωç‰ª•ÂÜÖ„ÅÆÂª∫Áâ©„ÅÆ„Åø„ÉÅ„Çß„ÉÉ„ÇØ
                    }
                    return false;
                });
                
                const intersects = raycaster.intersectObjects(nearbyObjects, true);
                
                // Âª∫Áâ©„ÇÑÈöúÂÆ≥Áâ©„Å®„ÅÆË°ùÁ™Å„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                for (const intersect of intersects) {
                    if (intersect.object.geometry.type === 'BoxGeometry' && 
                        intersect.distance < 0.1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            spawnInitialZombies(playerPosition) {
                // ÊúÄÂ§ßÊï∞„ÅÆ„Çæ„É≥„Éì„Çí‰∏ÄÂ∫¶„Å´ÁîüÊàê
                for (let i = 0; i < this.maxZombies; i++) {
                    this.spawnZombie(playerPosition);
                }
            }
            
            clear() {
                for (const zombie of this.zombies) {
                    zombie.remove();
                }
                this.zombies.clear();
                this.zombiesArray = [];
                this.currentZombieIndex = 0;
            }
        }
        
        // „Éó„É¨„Ç§„É§„Éº„Çπ„ÉÜ„Éº„Çø„Çπ„ÇØ„É©„Çπ
        class PlayerStatus {
            constructor() {
                this.maxValue = 100;
                this.health = this.maxValue;
                this.hunger = this.maxValue;
                this.thirst = this.maxValue;
                this.bleeding = this.maxValue;
                this.hygiene = this.maxValue;
                this.temperature = this.maxValue;
                
                // „Çπ„ÉÜ„Éº„Çø„ÇπÊ∏õÂ∞ë„ÅÆ„Çø„Ç§„Éû„Éº
                this.lastUpdateTime = Date.now();
                this.updateInterval = 1000; // 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞
                
                // „Çπ„ÉÜ„Éº„Çø„ÇπÊ∏õÂ∞ëÁéá
                this.decreaseRates = {
                    hunger: 0.1,      // Á©∫ËÖπÂ∫¶„ÅÆÊ∏õÂ∞ëÁéá
                    thirst: 0.15,     // Âñâ„ÅÆÊ∏á„Åç„ÅÆÊ∏õÂ∞ëÁéá
                    hygiene: 0.05,    // Ë°õÁîüÁä∂ÊÖã„ÅÆÊ∏õÂ∞ëÁéá
                    temperature: 0.02    // ‰ΩìÊ∏©„ÅÆÊ∏õÂ∞ëÁéá
                };
            }
            
            update(isMoving, currentBiome) {
                const currentTime = Date.now();
                if (currentTime - this.lastUpdateTime >= this.updateInterval) {
                    this.lastUpdateTime = currentTime;
                    
                    // ÁßªÂãï‰∏≠„ÅØÁ©∫ËÖπ„Å®Âñâ„ÅÆÊ∏á„Åç„ÅåÊ∏õÂ∞ë
                    if (isMoving) {
                        this.hunger = Math.max(0, this.hunger - this.decreaseRates.hunger);
                        this.thirst = Math.max(0, this.thirst - this.decreaseRates.thirst);
                    }
                    
                    // Ê£Æ„ÅÆ‰∏≠„Åß„ÅØË°õÁîüÁä∂ÊÖã„ÅåÊ∏õÂ∞ë
                    if (currentBiome.name === "Ê£ÆÊûó") {
                        this.hygiene = Math.max(0, this.hygiene - this.decreaseRates.hygiene);
                    }
                    
                    // ‰ΩìÊ∏©„ÅÆËá™ÁÑ∂Ê∏õÂ∞ë
                    this.temperature = Math.max(0, this.temperature - this.decreaseRates.temperature);
                    
                    // Âá∫Ë°Ä„ÄÅÁ©∫ËÖπ„ÄÅÂñâ„ÅÆÊ∏á„Åç„ÄÅË°õÁîüÁä∂ÊÖã„ÄÅ‰ΩìÊ∏©„Åå0„ÅÆÂ†¥Âêà„ÄÅ‰ΩìÂäõ„ÅåÊ∏õÂ∞ë
                    if (this.bleeding <= 0 || this.hunger <= 0 || this.thirst <= 0 || 
                        this.hygiene <= 0 || this.temperature <= 0) {
                        this.health = Math.max(0, this.health - 0.5);
                    }
                    
                    // ‰ΩìÂäõ„Åå0„Å´„Å™„Å£„Åü„Çâ„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
                    if (this.health <= 0) {
                        this.gameOver();
                    }
                    
                    this.updateUI();
                }
            }
            
            takeDamage(amount) {
                this.bleeding = Math.max(0, this.bleeding - amount);
                this.updateUI();
            }
            
            updateUI() {
                document.getElementById('health-fill').style.width = `${this.health}%`;
                document.getElementById('hunger-fill').style.width = `${this.hunger}%`;
                document.getElementById('thirst-fill').style.width = `${this.thirst}%`;
                document.getElementById('bleeding-fill').style.width = `${this.bleeding}%`;
                document.getElementById('hygiene-fill').style.width = `${this.hygiene}%`;
                document.getElementById('temperature-fill').style.width = `${this.temperature}%`;
            }
            
            gameOver() {
                document.getElementById('game-over').style.display = 'block';
            }
        }
        
        // „Éû„ÉÉ„Éó„ÅÆÂàùÊúüÁîüÊàê
        let cityMap = new CityMap(config, scene);
        let mapMeshes = cityMap.generate();
        scene.add(mapMeshes);
        
        // „Ç≠„É£„É©„ÇØ„Çø„Éº„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„ÅÆÂàùÊúüÂåñ
        const characterController = new CharacterController(scene, camera, topDownCamera);
        
        // „Çæ„É≥„Éì„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆÂàùÊúüÂåñ„Å®ÂàùÊúü„Çæ„É≥„Éì„ÅÆÁîüÊàê
        const zombieManager = new ZombieManager(scene);
        zombieManager.spawnInitialZombies(characterController.character.position);
        
        // ÊôÇÈñì„Ç∑„Çπ„ÉÜ„É†„ÅÆÂàùÊúüÂåñ
        class TimeSystem {
            constructor() {
                this.hour = 9; // ÈñãÂßãÊôÇÈñìÔºà6ÊôÇÔºâ
                this.minute = 0;
                //this.timeScale = 60; // 1Áßí„Åß1ÂàÜÈÄ≤„ÇÄ
                this.timeScale = 1; // 1Áßí„Åß1ÂàÜÈÄ≤„ÇÄ
                this.lastUpdate = Date.now();
                
                // ÊôÇÈñìÂ∏Ø„Åî„Å®„ÅÆËâ≤Ë®≠ÂÆö
                this.timeColors = {
                    dawn: { sky: 0xff7e50, ambient: 0x404040 }, // Â§úÊòé„Åë (5-7ÊôÇ)
                    day: { sky: 0x87ceeb, ambient: 0xffffff },  // Êó•‰∏≠ (7-17ÊôÇ)
                    dusk: { sky: 0xff7e50, ambient: 0x404040 }, // Â§ïÊöÆ„Çå (17-19ÊôÇ)
                    night: { sky: 0x000033, ambient: 0x202020 } // Â§ú (19-5ÊôÇ)
                };
                
                // Â§™ÈôΩ„ÅÆ‰ΩçÁΩÆË®àÁÆóÁî®
                this.sunRadius = 100;
                this.sunHeight = 50;
            }
            
            update() {
                const currentTime = Date.now();
                const deltaTime = (currentTime - this.lastUpdate) / 1000;
                this.lastUpdate = currentTime;
                
                // ÊôÇÈñì„ÅÆÊõ¥Êñ∞
                this.minute += deltaTime * this.timeScale;
                if (this.minute >= 60) {
                    this.hour = (this.hour + Math.floor(this.minute / 60)) % 24;
                    this.minute = this.minute % 60;
                }
                
                // UI„ÅÆÊõ¥Êñ∞
                document.getElementById('current-time').textContent = 
                    `ÊôÇÈñì: ${String(this.hour).padStart(2, '0')}:${String(Math.floor(this.minute)).padStart(2, '0')}`;
                
                return this.getTimeOfDay();
            }
            
            getTimeOfDay() {
                if (this.hour >= 5 && this.hour < 7) return 'dawn';
                if (this.hour >= 7 && this.hour < 17) return 'day';
                if (this.hour >= 17 && this.hour < 19) return 'dusk';
                return 'night';
            }
            
            getSunPosition() {
                const timeOfDay = this.getTimeOfDay();
                let sunAngle;
                
                switch(timeOfDay) {
                    case 'dawn':
                        sunAngle = (this.hour - 5 + this.minute / 60) * Math.PI / 2;
                        break;
                    case 'day':
                        sunAngle = Math.PI / 2 + (this.hour - 7 + this.minute / 60) * Math.PI / 10;
                        break;
                    case 'dusk':
                        sunAngle = Math.PI + (this.hour - 17 + this.minute / 60) * Math.PI / 2;
                        break;
                    case 'night':
                        sunAngle = Math.PI + (this.hour - 19 + this.minute / 60) * Math.PI / 10;
                        break;
                }
                
                return {
                    x: Math.cos(sunAngle) * this.sunRadius,
                    y: Math.sin(sunAngle) * this.sunHeight,
                    z: Math.sin(sunAngle) * this.sunRadius
                };
            }
            
            getSkyColor() {
                return this.timeColors[this.getTimeOfDay()].sky;
            }
            
            getAmbientLight() {
                return this.timeColors[this.getTimeOfDay()].ambient;
            }
        }
        
        // ÊôÇÈñì„Ç∑„Çπ„ÉÜ„É†„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
        const timeSystem = new TimeSystem();
        
        // Â§™ÈôΩ„ÅÆ‰ΩúÊàê
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
        function animate() {
            requestAnimationFrame(animate);
            
            // ÊôÇÈñì„ÅÆÊõ¥Êñ∞
            const timeOfDay = timeSystem.update();
            
            // Â§™ÈôΩ„ÅÆ‰ΩçÁΩÆÊõ¥Êñ∞
            const sunPos = timeSystem.getSunPosition();
            sun.position.set(sunPos.x, sunPos.y, sunPos.z);
            
            // Á©∫„ÅÆËâ≤„ÇíÊõ¥Êñ∞
            scene.background = new THREE.Color(timeSystem.getSkyColor());
            
            // Áí∞Â¢ÉÂÖâ„ÇíÊõ¥Êñ∞
            ambientLight.color.setHex(timeSystem.getAmbientLight());
            
            // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆ‰ΩçÁΩÆ„Å´Âü∫„Å•„ÅÑ„Å¶Êñ∞„Åó„ÅÑ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁîüÊàê
            const characterPos = characterController.character.position;
            const sectionX = Math.floor(characterPos.x / config.width);
            const sectionZ = Math.floor(characterPos.z / config.height);
            
            // „Éó„É¨„Ç§„É§„ÉºÊÉÖÂ†±„ÅÆÊõ¥Êñ∞
            document.getElementById('position').textContent = 
                `‰ΩçÁΩÆ: X: ${characterPos.x.toFixed(2)}, Y: ${characterPos.y.toFixed(2)}, Z: ${characterPos.z.toFixed(2)}`;
            
            // „Éê„Ç§„Ç™„Éº„É†ÊÉÖÂ†±„ÅÆÊõ¥Êñ∞
            const currentBiome = cityMap.getBiome(characterPos.x, characterPos.z);
            document.getElementById('biome').textContent = `„Éê„Ç§„Ç™„Éº„É†: ${currentBiome.name}`;
            
            // „Çæ„É≥„Éì„ÅÆÊï∞„ÇíË°®Á§∫
            document.getElementById('zombie-count').textContent = `„Çæ„É≥„ÉìÊï∞: ${zombieManager.zombies.size}`;
            
            // Âë®Âõ≤„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÁîüÊàê
            for (let x = sectionX - 1; x <= sectionX + 1; x++) {
                for (let z = sectionZ - 1; z <= sectionZ + 1; z++) {
                    if (!cityMap.hasSection(x * config.width, z * config.height)) {
                        cityMap.generateSection(x, z);
                    }
                }
            }
            
            // „Çæ„É≥„Éì„ÅÆÊõ¥Êñ∞
            zombieManager.update(characterPos);
            
            characterController.update();
            renderer.render(scene, characterController.currentCamera);
            
            // Âºæ‰∏∏„Å®„Çæ„É≥„Éì„ÅÆË°ùÁ™ÅÂà§ÂÆö
            checkBulletCollisions(characterController.bullets, zombieManager.zombiesArray);
        }
        
        animate();
        
        // Ë°ùÁ™ÅÂà§ÂÆö„ÇíËøΩÂä†
        function checkBulletCollisions(bullets, zombies) {
            for (const bullet of bullets) {
                for (const zombie of zombies) {
                    if (zombie.isDead) continue;
                    
                    const distance = bullet.mesh.position.distanceTo(zombie.mesh.position);
                    if (distance < 0.1) { // Ë°ùÁ™ÅÂà§ÂÆö„ÅÆË∑ùÈõ¢
                        zombie.takeDamage();
                        bullet.remove();
                        break;
                    }
                }
            }
        }
    </script>
</body>
</html>