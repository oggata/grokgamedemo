<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ©ãƒ³ãƒ€ãƒ éƒ½å¸‚ãƒãƒƒãƒ—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
        }

        #player-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: right;
        }
        #time-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        button {
            margin-top: 10px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #joystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 75px;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            transform: translate(-50%, -50%);
        }
        #jump-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            touch-action: none;
        }
        #camera-switch {
            margin-left: 10px;
            background-color: #2196F3;
        }
        #camera-switch:hover {
            background-color: #1976D2;
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚²ãƒ¼ã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #status-container {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        
        .status-bar {
            width: 100%;
            height: 15px;
            margin: 5px 0;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .status-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        
        .status-label {
            color: white;
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        #health-fill { background-color: #ff4444; }
        #hunger-fill { background-color: #ffaa44; }
        #thirst-fill { background-color: #44aaff; }
        #bleeding-fill { background-color: #ff44ff; }
        #hygiene-fill { background-color: #44ff44; }
        #temperature-fill { background-color: #ffff44; }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        #inventory-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            height: 60%;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            display: none;
            color: white;
        }
        
        #inventory-list {
            height: calc(100% - 40px);
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .inventory-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
            gap: 10px;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .inventory-item button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
        }
        
        .inventory-item button:hover {
            background: #45a049;
        }
        
        .inventory-item button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .control-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .control-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            touch-action: none;
        }
        
        .control-button:active {
            background: rgba(255, 255, 255, 0.3);
        }
        
        #attack-button {
            background: rgba(255, 0, 0, 0.3);
        }
        
        #jump-button {
            background: rgba(0, 255, 0, 0.3);
        }
        
        #bag-button {
            background: rgba(0, 0, 255, 0.3);
        }
        
        #camera-button {
            background: rgba(255, 255, 0, 0.3);
        }
    </style>
</head>
<body>

    
    <div id="player-info">
        <div id="position">ä½ç½®: X: 0.00, Y: 0.00, Z: 0.00</div>
        <div id="biome">ãƒã‚¤ã‚ªãƒ¼ãƒ : éƒ½å¸‚</div>
        <div id="zombie-count">ã‚¾ãƒ³ãƒ“æ•°: 0</div>
    </div>
    
    <div id="time-display">
        <div id="current-time">æ™‚é–“: 06:00</div>
    </div>
    
    <div id="crosshair"></div>
    <div id="joystick">
        <div id="joystick-knob"></div>
    </div>
    
    <div class="control-buttons">
        <div id="attack-button" class="control-button">ğŸ”«</div>
        <div id="jump-button" class="control-button">â¬†ï¸</div>
        <div id="bag-button" class="control-button">ğŸ’</div>
        <div id="camera-button" class="control-button">ğŸ“·</div>
    </div>
    
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚²ãƒ¼ã‚¸ -->
    <div id="status-container">
        <div class="status-label">ä½“åŠ›</div>
        <div class="status-bar"><div id="health-fill" class="status-fill"></div></div>
        <div class="status-label">ç©ºè…¹</div>
        <div class="status-bar"><div id="hunger-fill" class="status-fill"></div></div>
        <div class="status-label">å–‰ã®æ¸‡ã</div>
        <div class="status-bar"><div id="thirst-fill" class="status-fill"></div></div>
        <div class="status-label">å‡ºè¡€</div>
        <div class="status-bar"><div id="bleeding-fill" class="status-fill"></div></div>
        <div class="status-label">è¡›ç”ŸçŠ¶æ…‹</div>
        <div class="status-bar"><div id="hygiene-fill" class="status-fill"></div></div>
        <div class="status-label">ä½“æ¸©</div>
        <div class="status-bar"><div id="temperature-fill" class="status-fill"></div></div>
    </div>
    
    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
    <div id="game-over">
        <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
        <p>ã‚ãªãŸã¯ç”Ÿå­˜ã«å¤±æ•—ã—ã¾ã—ãŸ...</p>
        <button onclick="location.reload()">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>
    

    
    <!-- ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒ‘ãƒãƒ« -->
    <div id="inventory-panel">
        <h2>æŒã¡ç‰©</h2>
        <div id="inventory-list"></div>
    </div>
    
    <!-- æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®Three.jsã‚’ä½¿ç”¨ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- OrbitControlsã¯åˆ¥é€”ã‚¤ãƒ³ãƒãƒ¼ãƒˆ (Three.jsã®ä¸€éƒ¨ã¨ã—ã¦) -->
    <script>
        // OrbitControlsã®å®Ÿè£… (Three.jsã«å«ã¾ã‚Œãªããªã£ãŸãŸã‚ç›´æ¥å®Ÿè£…)
        // https://github.com/mrdoob/three.js/blob/dev/examples/jsm/controls/OrbitControls.js ã‚’åŸºã«ç°¡ç•¥åŒ–
        THREE.OrbitControls = function(object, domElement) {
            this.object = object;
            this.domElement = (domElement !== undefined) ? domElement : document;
            
            // API
            this.enabled = true;
            this.center = new THREE.Vector3();
            
            this.enableDamping = false;
            this.dampingFactor = 0.25;
            
            this.minDistance = 0;
            this.maxDistance = Infinity;
            
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            
            // ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³
            this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            
            // å†…éƒ¨çŠ¶æ…‹
            var scope = this;
            
            var EPS = 0.000001;
            
            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();
            
            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            
            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();
            
            var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };
            var state = STATE.NONE;
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ä¸­ã«æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å€¤
            this.update = function() {
                // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’ä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«æ›´æ–°
                var position = scope.object.position;
                
                position.clampLength(scope.minDistance, scope.maxDistance);
                
                return false;
            };
            
            function getAutoRotationAngle() {
                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }
            
            function getZoomScale() {
                return Math.pow(0.95, scope.zoomSpeed);
            }
            
            function onMouseDown(event) {
                event.preventDefault();
                
                if (scope.enabled === false) return;
                
                if (event.button === scope.mouseButtons.ROTATE) {
                    state = STATE.ROTATE;
                    rotateStart.set(event.clientX, event.clientY);
                } else if (event.button === scope.mouseButtons.DOLLY) {
                    state = STATE.DOLLY;
                    dollyStart.set(event.clientX, event.clientY);
                } else if (event.button === scope.mouseButtons.PAN) {
                    state = STATE.PAN;
                    panStart.set(event.clientX, event.clientY);
                }
                
                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);
            }
            
            function onMouseMove(event) {
                event.preventDefault();
                
                if (scope.enabled === false) return;
                
                if (state === STATE.ROTATE) {
                    rotateEnd.set(event.clientX, event.clientY);
                    rotateDelta.subVectors(rotateEnd, rotateStart);
                    
                    // å›è»¢å‡¦ç†
                    rotateLeft(2 * Math.PI * rotateDelta.x / scope.domElement.clientWidth);
                    rotateUp(2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight);
                    
                    rotateStart.copy(rotateEnd);
                } else if (state === STATE.DOLLY) {
                    dollyEnd.set(event.clientX, event.clientY);
                    dollyDelta.subVectors(dollyEnd, dollyStart);
                    
                    if (dollyDelta.y > 0) {
                        dollyOut(getZoomScale());
                    } else if (dollyDelta.y < 0) {
                        dollyIn(getZoomScale());
                    }
                    
                    dollyStart.copy(dollyEnd);
                } else if (state === STATE.PAN) {
                    panEnd.set(event.clientX, event.clientY);
                    panDelta.subVectors(panEnd, panStart);
                    
                    pan(panDelta.x, panDelta.y);
                    
                    panStart.copy(panEnd);
                }
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove, false);
                document.removeEventListener('mouseup', onMouseUp, false);
                
                state = STATE.NONE;
            }
            
            function onMouseWheel(event) {
                event.preventDefault();
                event.stopPropagation();
                
                if (event.deltaY < 0) {
                    dollyIn(getZoomScale());
                } else if (event.deltaY > 0) {
                    dollyOut(getZoomScale());
                }
            }
            
            function onKeyDown(event) {
                if (scope.enabled === false) return;
                
                switch (event.keyCode) {
                    case 38: // up arrow
                        dollyIn(getZoomScale());
                        break;
                    case 40: // down arrow
                        dollyOut(getZoomScale());
                        break;
                }
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            scope.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
            scope.domElement.addEventListener('mousedown', onMouseDown, false);
            scope.domElement.addEventListener('wheel', onMouseWheel, false);
            scope.domElement.addEventListener('keydown', onKeyDown, false);
            
            // ã‚«ãƒ¡ãƒ©æ“ä½œé–¢æ•°
            function rotateLeft(angle) {
                // Yè»¸å‘¨ã‚Šã®å›è»¢
                var quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                scope.object.position.sub(scope.center);
                scope.object.position.applyQuaternion(quaternion);
                scope.object.position.add(scope.center);
                scope.object.lookAt(scope.center);
            }
            
            function rotateUp(angle) {
                // æ°´å¹³è»¸å‘¨ã‚Šã®å›è»¢
                var axis = new THREE.Vector3().crossVectors(scope.object.up, new THREE.Vector3().subVectors(scope.object.position, scope.center).normalize());
                var quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                scope.object.position.sub(scope.center);
                scope.object.position.applyQuaternion(quaternion);
                scope.object.position.add(scope.center);
                scope.object.lookAt(scope.center);
            }
            
            function dollyIn(dollyScale) {
                scale /= dollyScale;
            }
            
            function dollyOut(dollyScale) {
                scale *= dollyScale;
            }
            
            function pan(deltaX, deltaY) {
                var offset = new THREE.Vector3();
                
                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                
                // ãƒ‘ãƒ¼ã‚¹ãƒšã‚¯ãƒ†ã‚£ãƒ–
                var position = scope.object.position;
                offset.copy(position).sub(scope.center);
                var targetDistance = offset.length();
                
                // è¦–é‡è§’ã«åŸºã¥ã„ã¦ãƒ‘ãƒ³é€Ÿåº¦ã‚’è¨ˆç®—
                targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);
                
                // å·¦å³ã«å‹•ã‹ã™
                var movLeft = new THREE.Vector3();
                movLeft.crossVectors(scope.object.up, offset).setLength(2 * deltaX * targetDistance / element.clientHeight);
                
                // ä¸Šä¸‹ã«å‹•ã‹ã™
                var movUp = new THREE.Vector3();
                movUp.copy(scope.object.up).setLength(2 * deltaY * targetDistance / element.clientHeight);
                
                scope.object.position.add(movUp).add(movLeft);
                scope.center.add(movUp).add(movLeft);
                
                scope.object.lookAt(scope.center);
            }
            
            var scale = 1;
            
            this.update();
        };
        
        THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>
    
    <script>
        // ãƒãƒƒãƒ—ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        const config = {
            width: 50,            // ãƒãƒƒãƒ—ã®å¹…
            height: 30,           // ãƒãƒƒãƒ—ã®é«˜ã•
            minBlockSize: 1,      // ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å°ã‚µã‚¤ã‚º
            maxBlockSize: 6,      // ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å¤§ã‚µã‚¤ã‚º
            roadWidth: {
                min: 0.2,         // æœ€å°é“è·¯å¹…
                max: 0.5,         // æœ€å¤§é“è·¯å¹…
                main: 0.8         // ãƒ¡ã‚¤ãƒ³é“è·¯å¹…
            },
            subdivisionChance: 0.6, // ãƒ–ãƒ­ãƒƒã‚¯ã‚’åˆ†å‰²ã™ã‚‹ç¢ºç‡
            maxSubdivisions: 4,   // æœ€å¤§åˆ†å‰²å›æ•°
            buildingHeight: {
                min: 0.3,         // æœ€å°å»ºç‰©é«˜ã•
                max: 4,           // æœ€å¤§å»ºç‰©é«˜ã•
                commercial: 3,    // å•†æ¥­åœ°åŒºã®å»ºç‰©é«˜ã•
                residential: 1.5  // ä½å®…åœ°åŒºã®å»ºç‰©é«˜ã•
            },
            parkChance: 0.2,      // å…¬åœ’ãŒç”Ÿæˆã•ã‚Œã‚‹ç¢ºç‡
            treeSpacing: 20,      // æœ¨ã®é–“éš”
            biomeSize: 25,        // ãƒã‚¤ã‚ªãƒ¼ãƒ ã®ã‚µã‚¤ã‚ºï¼ˆ100ã‹ã‚‰25ã«å¤‰æ›´ï¼‰
            colors: {
                background: 0x8888ff, // èƒŒæ™¯ã®è‰²
                highlight: 0x8888ff   // ãƒã‚¤ãƒ©ã‚¤ãƒˆã®è‰²
            },
            biomes: {
                city: {
                    name: "éƒ½å¸‚",
                    colors: {
                        road: 0x228822,       // é“è·¯ã®è‰²ï¼ˆæš—ã„ã‚°ãƒ¬ãƒ¼ï¼‰
                        ground: 0x228822,     // åºŠã®è‰²ï¼ˆã‚ˆã‚Šæš—ã„ã‚°ãƒ¬ãƒ¼ï¼‰
                        block: 0x228822,      // ãƒ–ãƒ­ãƒƒã‚¯ã®è‰²
                        park: 0x228822,       // å…¬åœ’ã®è‰²
                        tree: 0x228822        // æœ¨ã®è‰²
                    }
                },
                grassland: {
                    name: "è‰åŸ",
                    colors: {
                        road: 0x228822,       // é“è·¯ã®è‰²ï¼ˆé»„åœŸè‰²ï¼‰
                        ground: 0x228822,     // åºŠã®è‰²ï¼ˆæ˜ã‚‹ã„ç·‘ï¼‰
                        block: 0x228822,      // ãƒ–ãƒ­ãƒƒã‚¯ã®è‰²
                        park: 0x228822,       // å…¬åœ’ã®è‰²
                        tree: 0x228822        // æœ¨ã®è‰²
                    }
                },
                forest: {
                    name: "æ£®æ—",
                    colors: {
                        road: 0x228822,       // é“è·¯ã®è‰²ï¼ˆæš—ã„ç·‘ï¼‰
                        ground: 0x228822,     // åºŠã®è‰²ï¼ˆæ·±ã„ç·‘ï¼‰
                        block: 0x228822,      // ãƒ–ãƒ­ãƒƒã‚¯ã®è‰²
                        park: 0x228822,       // å…¬åœ’ã®è‰²
                        tree: 0x228822        // æœ¨ã®è‰²
                    }
                },
                rural: {
                    name: "è¾²æ‘",
                    colors: {
                        road: 0x8B4513,       // é“è·¯ã®è‰²ï¼ˆèŒ¶è‰²ï¼‰
                        ground: 0xA67C52,     // åºŠã®è‰²ï¼ˆæ˜ã‚‹ã„èŒ¶è‰²ï¼‰
                        block: 0x6B4423,      // ãƒ–ãƒ­ãƒƒã‚¯ã®è‰²
                        park: 0x4A7C59,       // å…¬åœ’ã®è‰²
                        tree: 0x31572C        // æœ¨ã®è‰²
                    }
                }
            }
        };

        // ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.colors.background);
        
        // ã‚«ãƒ¡ãƒ©ã®è¨­å®š
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const topDownCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        let currentCamera = camera;
        
        // ã‚«ãƒ¡ãƒ©ã®åˆæœŸä½ç½®è¨­å®š
        camera.position.set(0, 0.1, 0.3);
        topDownCamera.position.set(0, 5, 5);
        topDownCamera.lookAt(0, 0, 0);
        
        // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®è¨­å®š
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¨­å®š
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.center.set(0, 0, 0);
        
        // å…‰æºã®è¨­å®š
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        // BSPãƒ„ãƒªãƒ¼é¢¨ã®ãƒ–ãƒ­ãƒƒã‚¯åˆ†å‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ãƒãƒƒãƒ—ã‚’ç”Ÿæˆã™ã‚‹
        class Block {
            constructor(x, y, width, height, depth = 0.5) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.subdivided = false;
                this.children = [];
            }
            
            subdivide() {
                if (this.subdivided || 
                    this.width <= config.minBlockSize || 
                    this.height <= config.minBlockSize) {
                    return false;
                }
                
                // åˆ†å‰²å›æ•°ã®åˆ¶é™
                if (Math.random() > Math.pow(config.subdivisionChance, this.getDepth())) {
                    return false;
                }
                
                // æ°´å¹³ã¾ãŸã¯å‚ç›´ã«åˆ†å‰²ã™ã‚‹ã‹ã‚’æ±ºå®š
                let horizontal = Math.random() < 0.5;
                
                // ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚µã‚¤ã‚ºã«å¿œã˜ã¦åˆ†å‰²æ–¹å‘ã‚’èª¿æ•´
                if (this.width > this.height * 1.5) {
                    horizontal = false; // å¹…ãŒé«˜ã•ã‚ˆã‚Šå¤§ãã„å ´åˆã¯æ°´å¹³åˆ†å‰²ã‚’å„ªå…ˆ
                } else if (this.height > this.width * 1.5) {
                    horizontal = true;  // é«˜ã•ãŒå¹…ã‚ˆã‚Šå¤§ãã„å ´åˆã¯å‚ç›´åˆ†å‰²ã‚’å„ªå…ˆ
                }
                
                // åˆ†å‰²ä½ç½®ã‚’æ±ºå®šï¼ˆç«¯ã‹ã‚‰å°‘ã—å†…å´ï¼‰
                const minSplit = 0.3; // æœ€å°åˆ†å‰²æ¯”ç‡
                const maxSplit = 0.7; // æœ€å¤§åˆ†å‰²æ¯”ç‡
                const splitRatio = minSplit + Math.random() * (maxSplit - minSplit);
                
                // å®Ÿéš›ã®åˆ†å‰²å‡¦ç†
                if (horizontal) {
                    // æ°´å¹³åˆ†å‰²
                    const splitPoint = Math.floor(this.height * splitRatio);
                    if (splitPoint < config.minBlockSize || 
                        this.height - splitPoint < config.minBlockSize) {
                        return false;
                    }
                    
                    this.children.push(
                        new Block(this.x, this.y, this.width, splitPoint, this.depth + 1),
                        new Block(this.x, this.y + splitPoint, this.width, this.height - splitPoint, this.depth + 1)
                    );
                } else {
                    // å‚ç›´åˆ†å‰²
                    const splitPoint = Math.floor(this.width * splitRatio);
                    if (splitPoint < config.minBlockSize || 
                        this.width - splitPoint < config.minBlockSize) {
                        return false;
                    }
                    
                    this.children.push(
                        new Block(this.x, this.y, splitPoint, this.height, this.depth + 1),
                        new Block(this.x + splitPoint, this.y, this.width - splitPoint, this.height, this.depth + 1)
                    );
                }
                
                this.subdivided = true;
                
                // å†å¸°çš„ã«å­ãƒ–ãƒ­ãƒƒã‚¯ã‚‚åˆ†å‰²ã‚’è©¦ã¿ã‚‹
                for (const child of this.children) {
                    child.subdivide();
                }
                
                return true;
            }
            
            getDepth() {
                let depth = 0;
                let current = this;
                while (current.parent) {
                    depth++;
                    current = current.parent;
                }
                return depth;
            }
            
            getLeafBlocks() {
                if (!this.subdivided) {
                    return [this];
                }
                
                let leaves = [];
                for (const child of this.children) {
                    leaves = leaves.concat(child.getLeafBlocks());
                }
                return leaves;
            }
        }
        
        // ãƒãƒƒãƒ—ç”Ÿæˆã‚¯ãƒ©ã‚¹
        class CityMap {
            constructor(config, scene) {
                this.config = config;
                this.scene = scene;
                this.blocks = [];
                this.meshes = new THREE.Group();
                this.buildOutline = new THREE.Group();
                this.roadNetwork = new THREE.Group();
                this.mapSections = new Map(); // ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†
                this.currentSection = '0,0'; // ç¾åœ¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³
            }
            
            // ãƒã‚¤ã‚ªãƒ¼ãƒ ã‚’æ±ºå®šã™ã‚‹é–¢æ•°
            getBiome(x, z) {
                // ãƒã‚¤ã‚ªãƒ¼ãƒ ã®ã‚µã‚¤ã‚ºã«åŸºã¥ã„ã¦ãƒã‚¤ã‚ªãƒ¼ãƒ ã‚’æ±ºå®š
                const biomeX = Math.floor(x / this.config.biomeSize);
                const biomeZ = Math.floor(z / this.config.biomeSize);
                
                // ãƒã‚¤ã‚ªãƒ¼ãƒ ã®ç¨®é¡ã‚’æ±ºå®šï¼ˆä½ç½®ã«åŸºã¥ã„ã¦æ±ºå®šï¼‰
                const biomeTypes = Object.keys(this.config.biomes);
                const index = Math.abs((biomeX * 7919 + biomeZ * 6037)) % biomeTypes.length;
                const biomeType = biomeTypes[index];
                
                return this.config.biomes[biomeType] || this.config.biomes.city;
            }
            
            // è‰²ã®è£œé–“ã‚’è¡Œã†ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
            interpolateColor(color1, color2, factor) {
                const r1 = (color1 >> 16) & 255;
                const g1 = (color1 >> 8) & 255;
                const b1 = color1 & 255;
                
                const r2 = (color2 >> 16) & 255;
                const g2 = (color2 >> 8) & 255;
                const b2 = color2 & 255;
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return (r << 16) | (g << 8) | b;
            }
            
            // åˆæœŸãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
            generate() {
                // ä¸­å¿ƒã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ0,0ï¼‰ã‚’ç”Ÿæˆ
                this.generateSection(0, 0);
                
                // å‘¨å›²ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚ç”Ÿæˆ
                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x !== 0 || z !== 0) {
                            this.generateSection(x, z);
                        }
                    }
                }

                // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿæˆ
                this.generateItems();
                
                return this.meshes;
            }

            // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
            generateItems() {
                const sectionSize = this.config.width;
                const totalSections = 9; // 3x3ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³
                const itemsPerSection = Math.floor(itemManager.maxItems / totalSections);

                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        const sectionX = x * sectionSize;
                        const sectionZ = z * sectionSize;

                        // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                        for (let i = 0; i < itemsPerSection; i++) {
                            const position = new THREE.Vector3(
                                sectionX + (Math.random() - 0.5) * sectionSize,
                                1,
                                sectionZ + (Math.random() - 0.5) * sectionSize
                            );

                            // å»ºç‰©ã‚„éšœå®³ç‰©ã¨ã®è¡çªã‚’ãƒã‚§ãƒƒã‚¯
                            if (!this.checkItemSpawnCollision(position)) {
                                const type = itemManager.itemTypes[Math.floor(Math.random() * itemManager.itemTypes.length)];
                                const item = new Item(type, position);
                                item.createMesh();
                                this.scene.add(item.mesh);
                                itemManager.items.add(item);
                            }
                        }
                    }
                }
            }

            // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã®è¡çªåˆ¤å®š
            checkItemSpawnCollision(position) {
                const raycaster = new THREE.Raycaster();
                raycaster.set(position, new THREE.Vector3(0, -1, 0));
                
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(position);
                        return distance < 5;
                    }
                    return false;
                });
                
                const intersects = raycaster.intersectObjects(nearbyObjects, true);
                
                for (const intersect of intersects) {
                    if (intersect.object.geometry.type === 'BoxGeometry' && 
                        intersect.distance < 0.1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’å†å¸°çš„ã«åˆ†å‰²
            recursiveSubdivide(block, maxDepth) {
                if (maxDepth <= 0) return;
                
                let subdivided = false;
                for (const child of block.children) {
                    if (Math.random() < 0.7) { // 70%ã®ç¢ºç‡ã§åˆ†å‰²ã™ã‚‹
                        subdivided = child.subdivide() || subdivided;
                    }
                }
                
                if (subdivided) {
                    for (const child of block.children) {
                        this.recursiveSubdivide(child, maxDepth - 1);
                    }
                }
            }
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            getSectionKey(x, z) {
                const sectionX = Math.floor(x / this.config.width);
                const sectionZ = Math.floor(z / this.config.height);
                return `${sectionX},${sectionZ}`;
            }
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            hasSection(x, z) {
                return this.mapSections.has(this.getSectionKey(x, z));
            }
            
            // æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
            generateSection(sectionX, sectionZ) {
                const key = `${sectionX},${sectionZ}`;
                if (this.mapSections.has(key)) return;
                
                // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                const offsetX = sectionX * this.config.width;
                const offsetZ = sectionZ * this.config.height;
                
                // æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                const sectionMap = new THREE.Group();
                sectionMap.position.set(offsetX, 0, offsetZ);
                
                // æœ€åˆã®å¤§ããªãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ
                const rootBlock = new Block(0, 0, this.config.width, this.config.height);
                rootBlock.subdivide();
                
                // åˆ†å‰²ã‚’è¡Œã†
                this.recursiveSubdivide(rootBlock, this.config.maxSubdivisions);
                
                // åˆ†å‰²æ¸ˆã¿ã®ãƒªãƒ¼ãƒ•ãƒ–ãƒ­ãƒƒã‚¯ã ã‘ã‚’ä¿æŒ
                const blocks = rootBlock.getLeafBlocks();
                
                // ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
                this.createSectionMeshes(blocks, sectionMap, offsetX, offsetZ);
                
                // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¿å­˜
                this.mapSections.set(key, {
                    meshes: sectionMap,
                    blocks: blocks
                });
                
                // ã‚·ãƒ¼ãƒ³ã«è¿½åŠ 
                this.meshes.add(sectionMap);
            }
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
            createSectionMeshes(blocks, sectionMap, offsetX, offsetZ) {
                // ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒã‚¤ã‚ªãƒ¼ãƒ ã‚’å–å¾—
                const biome = this.getBiome(offsetX, offsetZ);
                
                // åœ°é¢ã‚’ä½œæˆï¼ˆé“è·¯ã¨åŒã˜é«˜ã•ã«é…ç½®ï¼‰
                const groundGeometry = new THREE.PlaneGeometry(
                    this.config.width * 1.5, 
                    this.config.height * 1.5
                );
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.ground,
                    roughness: 0.8,
                    metalness: 0.2,
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0.1;
                ground.receiveShadow = true;
                sectionMap.add(ground);
                
                // ãƒã‚¤ã‚ªãƒ¼ãƒ ã”ã¨ã®ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
                switch(biome.name) {
                    case "éƒ½å¸‚":
                        this.createCityBuildings(blocks, sectionMap, biome);
                        break;
                    case "æ£®æ—":
                        this.createForest(blocks, sectionMap, biome);
                        break;
                    case "è‰åŸ":
                        this.createGrassland(blocks, sectionMap, biome);
                        break;
                    case "è¾²æ‘":
                        this.createRuralArea(blocks, sectionMap, biome);
                        break;
                }
                
                // é“è·¯ç¶²ã‚’è¿½åŠ ï¼ˆéƒ½å¸‚ã¨è¾²æ‘ã®ã¿ï¼‰
                if (biome.name === "éƒ½å¸‚" || biome.name === "è¾²æ‘") {
                    this.createRoadNetwork(blocks, sectionMap, offsetX, offsetZ, biome);
                }
            }
            
            // éƒ½å¸‚ã®ç”Ÿæˆ
            createCityBuildings(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    const blockSize = Math.min(block.width, block.height);
                    
                    // å…¬åœ’ã‹ã©ã†ã‹ã‚’æ±ºå®š
                    const isPark = Math.random() < this.config.parkChance;
                    
                    if (isPark) {
                        // å…¬åœ’ã‚’ä½œæˆ
                        const parkHeight = 0.2;
                        const parkGeometry = new THREE.BoxGeometry(
                            block.width - this.config.roadWidth.main,
                            parkHeight,
                            block.height - this.config.roadWidth.main
                        );
                        const parkMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.park,
                            roughness: 0.8,
                            metalness: 0.1,
                        });
                        const parkMesh = new THREE.Mesh(parkGeometry, parkMaterial);
                        parkMesh.position.set(
                            block.x + block.width / 2,
                            parkHeight / 2,
                            block.y + block.height / 2
                        );
                        parkMesh.receiveShadow = true;
                        sectionMap.add(parkMesh);
                        
                        // å…¬åœ’ã«æœ¨ã‚’è¿½åŠ 
                        this.addTrees(block, parkHeight, sectionMap, biome, 0.5);
                        continue;
                    }
                    
                    // å»ºç‰©ã®é«˜ã•ã‚’æ±ºå®š
                    let height;
                    if (blockSize > this.config.maxBlockSize * 0.7) {
                        height = this.config.buildingHeight.commercial + Math.random() * 2;
                    } else if (block.x % 2 === 0 && block.y % 2 === 0) {
                        height = this.config.buildingHeight.commercial;
                    } else if (blockSize < this.config.minBlockSize * 1.5) {
                        height = this.config.buildingHeight.residential;
                    } else {
                        height = this.config.buildingHeight.min + Math.random() * (this.config.buildingHeight.max - this.config.buildingHeight.min);
                    }
                    
                    // å»ºç‰©ã®ç¸ã‚’å°‘ã—å†…å´ã«ã™ã‚‹ï¼ˆé“è·¯ã‚¹ãƒšãƒ¼ã‚¹ï¼‰
                    const roadOffset = this.config.roadWidth.main;
                    const boxGeometry = new THREE.BoxGeometry(
                        block.width - roadOffset,
                        height,
                        block.height - roadOffset
                    );
                    
                    // å»ºç‰©ã®è‰²ã‚’æ±ºå®š
                    let blockColor;
                    if (blockSize > this.config.maxBlockSize * 0.7) {
                        blockColor = new THREE.Color(0x555577);
                    } else if (block.x % 2 === 0 && block.y % 2 === 0) {
                        blockColor = new THREE.Color(0x775577);
                    } else if (blockSize < this.config.minBlockSize * 1.5) {
                        blockColor = new THREE.Color(0x775555);
                    } else {
                        blockColor = new THREE.Color(0x555555);
                    }
                    
                    const boxMaterial = new THREE.MeshStandardMaterial({
                        color: blockColor,
                        roughness: 0.7,
                        metalness: 0.3,
                    });
                    const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                    boxMesh.position.set(
                        block.x + block.width / 2,
                        height / 2,
                        block.y + block.height / 2
                    );
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    sectionMap.add(boxMesh);
                }
            }
            
            // æ£®æ—ã®ç”Ÿæˆ
            createForest(blocks, sectionMap, biome) {
                // æœ¨ã‚’å¯†é›†ã—ã¦é…ç½®
                for (const block of blocks) {
                    const treeSpacing = 5; // æœ¨ã®é–“éš”ã‚’ç‹­ã
                    const treeHeight = 2 + Math.random() * 1; // æœ¨ã®é«˜ã•ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
                    const treeRadius = 0.5 + Math.random() * 0.3; // æœ¨ã®å¤ªã•ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
                    
                    for (let x = block.x; x < block.x + block.width; x += treeSpacing) {
                        for (let z = block.y; z < block.y + block.height; z += treeSpacing) {
                            // å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ãšã‚‰ã—ã¦é…ç½®
                            const offsetX = (Math.random() - 0.5) * treeSpacing;
                            const offsetZ = (Math.random() - 0.5) * treeSpacing;
                            this.createTree(x + offsetX, 0, z + offsetZ, treeHeight, treeRadius, sectionMap, biome);
                        }
                    }
                }
            }
            
            // è‰åŸã®ç”Ÿæˆ
            createGrassland(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    // ä½ã„å»ºç‰©ã‚’ç‚¹åœ¨ã•ã›ã‚‹
                    if (Math.random() < 0.3) { // 30%ã®ç¢ºç‡ã§å»ºç‰©ã‚’ç”Ÿæˆ
                        const height = 0.5 + Math.random() * 0.5; // ä½ã„å»ºç‰©
                        const width = 1 + Math.random() * 2;
                        const depth = 1 + Math.random() * 2;
                        
                        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.block,
                            roughness: 0.8,
                            metalness: 0.2,
                        });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(
                            block.x + block.width / 2,
                            height / 2,
                            block.y + block.height / 2
                        );
                        building.castShadow = true;
                        building.receiveShadow = true;
                        sectionMap.add(building);
                    }
                    
                    // è‰ã‚’ç”Ÿã‚„ã™
                    const grassSpacing = 3;
                    for (let x = block.x; x < block.x + block.width; x += grassSpacing) {
                        for (let z = block.y; z < block.y + block.height; z += grassSpacing) {
                            if (Math.random() < 0.7) { // 70%ã®ç¢ºç‡ã§è‰ã‚’ç”Ÿã‚„ã™
                                this.createGrass(x, 0, z, sectionMap, biome);
                            }
                        }
                    }
                }
            }
            
            // è¾²æ‘ã®ç”Ÿæˆ
            createRuralArea(blocks, sectionMap, biome) {
                for (const block of blocks) {
                    // ä½ã„å»ºç‰©ã‚’ç‚¹åœ¨ã•ã›ã‚‹
                    if (Math.random() < 0.4) { // 40%ã®ç¢ºç‡ã§å»ºç‰©ã‚’ç”Ÿæˆ
                        const height = 0.8 + Math.random() * 0.7; // ã‚„ã‚„é«˜ã„å»ºç‰©
                        const width = 2 + Math.random() * 3;
                        const depth = 2 + Math.random() * 3;
                        
                        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: biome.colors.block,
                            roughness: 0.8,
                            metalness: 0.2,
                        });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(
                            block.x + block.width / 2,
                            height / 2,
                            block.y + block.height / 2
                        );
                        building.castShadow = true;
                        building.receiveShadow = true;
                        sectionMap.add(building);
                    }
                    
                    // æœ¨ã‚’ç‚¹åœ¨ã•ã›ã‚‹
                    if (Math.random() < 0.2) { // 20%ã®ç¢ºç‡ã§æœ¨ã‚’ç”Ÿæˆ
                        const treeHeight = 1.5 + Math.random() * 0.5;
                        const treeRadius = 0.3;
                        this.createTree(
                            block.x + block.width / 2,
                            0,
                            block.y + block.height / 2,
                            treeHeight,
                            treeRadius,
                            sectionMap,
                            biome
                        );
                    }
                }
            }
            
            // è‰ã‚’ç”Ÿæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
            createGrass(x, y, z, sectionMap, biome) {
                const grassHeight = 0.2 + Math.random() * 0.3;
                const grassGeometry = new THREE.CylinderGeometry(0.05, 0.1, grassHeight, 4);
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.ground,
                    roughness: 0.8,
                    metalness: 0.1,
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.position.set(x, y + grassHeight / 2, z);
                grass.rotation.x = Math.random() * 0.2;
                grass.rotation.z = Math.random() * 0.2;
                grass.castShadow = true;
                sectionMap.add(grass);
            }
            
            // é“è·¯ç¶²ã‚’ç”Ÿæˆ
            createRoadNetwork(blocks, sectionMap, offsetX, offsetZ, biome) {
                // æ°´å¹³é“è·¯ã¨å‚ç›´é“è·¯ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆ
                const horizontalRoads = new Set();
                const verticalRoads = new Set();
                
                // ã™ã¹ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¨ãƒƒã‚¸ã‚’é“è·¯ã¨ã—ã¦ç™»éŒ²
                for (const block of blocks) {
                    horizontalRoads.add(block.y);
                    horizontalRoads.add(block.y + block.height);
                    verticalRoads.add(block.x);
                    verticalRoads.add(block.x + block.width);
                }
                
                // é“è·¯ã®å¹…ã‚’æ±ºå®šã™ã‚‹é–¢æ•°
                const getRoadWidth = (isMainRoad) => {
                    if (isMainRoad) {
                        return this.config.roadWidth.main;
                    }
                    return this.config.roadWidth.min + Math.random() * (this.config.roadWidth.max - this.config.roadWidth.min);
                };
                
                // ãƒ¡ã‚¤ãƒ³é“è·¯ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
                const isMainRoad = (position, roads) => {
                    const positions = Array.from(roads);
                    const index = positions.indexOf(position);
                    return index % 2 === 0 && index > 0 && index < positions.length - 1;
                };
                
                // æ°´å¹³é“è·¯ã®ä½œæˆ
                for (const y of horizontalRoads) {
                    const roadWidth = getRoadWidth(isMainRoad(y, horizontalRoads));
                    const roadGeometry = new THREE.PlaneGeometry(this.config.width * 1.5, roadWidth * 0.8);
                    const roadMaterial = new THREE.MeshStandardMaterial({
                        color: biome.colors.road,
                        roughness: 0.8,
                        metalness: 0.2,
                    });
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.01, y);
                    road.rotation.x = -Math.PI / 2;
                    sectionMap.add(road);
                }
                
                // å‚ç›´é“è·¯ã®ä½œæˆ
                for (const x of verticalRoads) {
                    const roadWidth = getRoadWidth(isMainRoad(x, verticalRoads));
                    const roadGeometry = new THREE.PlaneGeometry(roadWidth * 0.8, this.config.height * 1.5);
                    const roadMaterial = new THREE.MeshStandardMaterial({
                        color: biome.colors.road,
                        roughness: 0.8,
                        metalness: 0.2,
                    });
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(x, 0.01, 0);
                    road.rotation.x = -Math.PI / 2;
                    sectionMap.add(road);
                }
            }
            
            // 1æœ¬ã®æœ¨ã‚’ä½œæˆã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
            createTree(x, y, z, treeHeight, treeRadius, sectionMap, biome) {
                // æœ¨ã®å¹¹
                const trunkGeometry = new THREE.CylinderGeometry(treeRadius * 0.06, treeRadius * 0.09, treeHeight * 0.09, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1,
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, y + treeHeight * 0.045, z);
                trunk.castShadow = true;
                sectionMap.add(trunk);
                
                // æœ¨ã®è‘‰
                const leavesGeometry = new THREE.ConeGeometry(treeRadius * 0.3, treeHeight * 0.21, 8);
                const leavesMaterial = new THREE.MeshStandardMaterial({
                    color: biome.colors.tree,
                    roughness: 0.8,
                    metalness: 0.1,
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, y + treeHeight * 0.15, z);
                leaves.castShadow = true;
                sectionMap.add(leaves);
            }
            
            // å…¬åœ’ã«æœ¨ã‚’è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
            addTrees(block, baseHeight, sectionMap, biome, treeSpacing) {
                const treeHeight = 0.45;  // 1.5ã‹ã‚‰0.45ã«ç¸®å°
                const treeRadius = 0.09;  // 0.3ã‹ã‚‰0.09ã«ç¸®å°
                
                for (let x = block.x + treeSpacing; x < block.x + block.width - treeSpacing; x += treeSpacing) {
                    for (let z = block.y + treeSpacing; z < block.y + block.height - treeSpacing; z += treeSpacing) {
                        this.createTree(x, baseHeight, z, treeHeight, treeRadius, sectionMap, biome);
                    }
                }
            }
            
            // ãƒãƒƒãƒ—ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            clear() {
                scene.remove(this.meshes);
                this.blocks = [];
                this.meshes = new THREE.Group();
                this.buildOutline = new THREE.Group();
                this.roadNetwork = new THREE.Group();
                this.mapSections.clear();
            }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹
        class Item {
            constructor(type, position) {
                this.type = type;
                this.position = position;
                this.mesh = null;
                this.isCollected = false;
                
                // ã‚¢ã‚¤ãƒ†ãƒ ã®åŠ¹æœã‚’å®šç¾©
                this.effects = {
                    'ã‚·ãƒªã‚¢ãƒ«': { hunger: 30 },
                    'ã‚¯ãƒ©ãƒƒã‚«ãƒ¼': { hunger: 20 },
                    'ç¼¶è©°': { hunger: 40 },
                    'ã‚Šã‚“ã”': { hunger: 15 },
                    'ãƒˆãƒãƒˆ': { hunger: 10 },
                    'ã‹ã¼ã¡ã‚ƒ': { hunger: 25 },
                    'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«ã®æ°´': { thirst: 50 },
                    'åŒ…å¸¯': { bleeding: 50 },
                    'Tã‚·ãƒ£ãƒ„': { temperature: 20 },
                    'ã‚¸ãƒ¼ãƒ‘ãƒ³': { temperature: 15 }
                };
            }
            
            createMesh() {
                // ã‚¢ã‚¤ãƒ†ãƒ ã®è¦‹ãŸç›®ã‚’è¨­å®š
                const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
                const material = new THREE.MeshStandardMaterial({ 
                    color: this.getColor(),
                    emissive: this.getColor(),
                    emissiveIntensity: 0.5
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.position.y = 0.18; // åœ°é¢ã‹ã‚‰å°‘ã—æµ®ã‹ã›ã‚‹
                this.mesh.castShadow = true;
                
                // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                this.mesh.rotation.y = Math.random() * Math.PI * 2;
                this.rotationSpeed = 0.01;
            }
            
            update() {
                if (this.mesh) {
                    this.mesh.rotation.y += this.rotationSpeed;
                    //this.mesh.position.y = 0.01 + Math.sin(Date.now() * 0.003) * 0.005;
                }
            }
            
            getColor() {
                const colors = {
                    'ã‚·ãƒªã‚¢ãƒ«': 0xffd700,
                    'ã‚¯ãƒ©ãƒƒã‚«ãƒ¼': 0xffa500,
                    'ç¼¶è©°': 0xc0c0c0,
                    'ã‚Šã‚“ã”': 0xff0000,
                    'ãƒˆãƒãƒˆ': 0xff6347,
                    'ã‹ã¼ã¡ã‚ƒ': 0xffa500,
                    'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«ã®æ°´': 0x00ffff,
                    'åŒ…å¸¯': 0xffffff,
                    'Tã‚·ãƒ£ãƒ„': 0x4169e1,
                    'ã‚¸ãƒ¼ãƒ‘ãƒ³': 0x000080
                };
                return colors[this.type] || 0xffffff;
            }
            
            collect() {
                if (!this.isCollected) {
                    this.isCollected = true;
                    if (this.mesh) {
                        scene.remove(this.mesh);
                    }
                    return true;
                }
                return false;
            }
            
            applyEffect(playerStatus) {
                const effect = this.effects[this.type];
                if (effect) {
                    for (const [stat, value] of Object.entries(effect)) {
                        if (stat === 'temperature') {
                            // ä½“æ¸©æ¸›å°‘ç‡ã‚’ä¸‹ã’ã‚‹
                            playerStatus.decreaseRates.temperature *= 0.5;
                        } else {
                            // ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å›å¾©
                            playerStatus[stat] = Math.min(100, playerStatus[stat] + value);
                        }
                    }
                    playerStatus.updateUI();
                }
            }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹
        class ItemManager {
            constructor(scene) {
                this.scene = scene;
                this.items = new Set();
                this.spawnRadius = 10;
                this.despawnRadius = 10;
                this.maxItems = 100; // æœ€å¤§ã‚¢ã‚¤ãƒ†ãƒ æ•°ã‚’100ã«è¨­å®š
                this.itemTypes = [
                    'ã‚·ãƒªã‚¢ãƒ«', 'ã‚¯ãƒ©ãƒƒã‚«ãƒ¼', 'ç¼¶è©°', 'ã‚Šã‚“ã”', 'ãƒˆãƒãƒˆ',
                    'ã‹ã¼ã¡ã‚ƒ', 'ãƒšãƒƒãƒˆãƒœãƒˆãƒ«ã®æ°´', 'åŒ…å¸¯', 'Tã‚·ãƒ£ãƒ„', 'ã‚¸ãƒ¼ãƒ‘ãƒ³'
                ];
            }
            
            // ã‚¢ã‚¤ãƒ†ãƒ ã®æ›´æ–°å‡¦ç†ã‚’ä¿®æ­£
            update(playerPosition) {
                // ã‚¢ã‚¤ãƒ†ãƒ ã®æ›´æ–°ã¨ç®¡ç†
                for (const item of this.items) {
                    if (item.mesh) {
                        item.update();
                    }
                }
            }
            
            spawnItems(playerPosition) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿæˆ
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * this.spawnRadius;
                    const position = new THREE.Vector3(
                        playerPosition.x + Math.cos(angle) * distance,
                        1,
                        playerPosition.z + Math.sin(angle) * distance
                    );
                    
                    const type = this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)];
                    const item = new Item(type, position);
                    item.createMesh();
                    this.scene.add(item.mesh);
                    this.items.add(item);
                }
            }
            
            checkCollisions(playerPosition) {
                for (const item of this.items) {
                    if (item.mesh) {
                        const distance = item.mesh.position.distanceTo(playerPosition);
                        if (distance < 2.0) { // å–å¾—è·é›¢ã‚’2.0ã«æ‹¡å¤§
                            if (item.collect()) {
                                this.items.delete(item);
                                return item;
                            }
                        }
                    }
                }
                return null;
            }
        }
        
        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚¯ãƒ©ã‚¹
        class Inventory {
            constructor() {
                this.items = [];
                this.maxItems = 100;
                this.panel = document.getElementById('inventory-panel');
                this.list = document.getElementById('inventory-list');
                this.isOpen = false;
                

            }
            
            addItem(item) {
                if (this.items.length < this.maxItems) {
                    this.items.push(item);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            removeItem(index) {
                if (index >= 0 && index < this.items.length) {
                    this.items.splice(index, 1);
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            useItem(index, playerStatus) {
                if (index >= 0 && index < this.items.length) {
                    const item = this.items[index];
                    item.applyEffect(playerStatus);
                    this.removeItem(index);
                    return true;
                }
                return false;
            }
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panel.style.display = this.isOpen ? 'block' : 'none';
                if (this.isOpen) {
                    this.updateUI();
                }
            }
            
            updateUI() {
                this.list.innerHTML = '';
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
                const header = document.createElement('div');
                header.className = 'inventory-item';
                header.innerHTML = `
                    <div>åå‰</div>
                    <div>é£Ÿã¹ã‚‹</div>
                    <div>è£…å‚™ã™ã‚‹</div>
                    <div>çµ„ã¿åˆã‚ã›ã‚‹</div>
                    <div>æ¨ã¦ã‚‹</div>
                `;
                this.list.appendChild(header);
                
                // ã‚¢ã‚¤ãƒ†ãƒ è¡Œ
                this.items.forEach((item, index) => {
                    const row = document.createElement('div');
                    row.className = 'inventory-item';
                    row.innerHTML = `
                        <div>${item.type}</div>
                        <button onclick="inventory.useItem(${index}, characterController.status)">é£Ÿã¹ã‚‹</button>
                        <button onclick="inventory.useItem(${index}, characterController.status)">è£…å‚™ã™ã‚‹</button>
                        <button disabled>çµ„ã¿åˆã‚ã›ã‚‹</button>
                        <button onclick="inventory.removeItem(${index})">æ¨ã¦ã‚‹</button>
                    `;
                    this.list.appendChild(row);
                });
            }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®åˆæœŸåŒ–
        const itemManager = new ItemManager(scene);
        const inventory = new Inventory();
        
        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åˆ¶å¾¡ã‚¯ãƒ©ã‚¹
        class CharacterController {
            constructor(scene, camera, topDownCamera) {
                this.scene = scene;
                this.camera = camera;
                this.topDownCamera = topDownCamera;
                this.currentCamera = camera;
                this.moveSpeed = 0.01;
                this.rotationSpeed = 0.03;
                this.jumpForce = 0.5;
                this.gravity = 0.015;
                this.velocity = new THREE.Vector3();
                this.isJumping = false;
                this.isGrounded = false;
                this.raycaster = new THREE.Raycaster();
                this.collisionDistance = 0.1;
                
                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹
                this.joystick = {
                    active: false,
                    position: new THREE.Vector2(),
                    startPosition: new THREE.Vector2(),
                    currentPosition: new THREE.Vector2(),
                    element: document.getElementById('joystick'),
                    knob: document.getElementById('joystick-knob')
                };
                
                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®çŠ¶æ…‹
                this.gamepad = null;
                this.gamepadConnected = false;
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ä½œæˆ
                this.createCharacter();
                
                // å…¥åŠ›çŠ¶æ…‹
                this.keys = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    jump: false
                };
                
                // ãƒã‚¦ã‚¹åˆ¶å¾¡
                this.mouseSensitivity = 0.002;
                this.mouseX = 0;
                this.mouseY = 0;
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
                this.setupEventListeners();
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®åˆæœŸåŒ–
                this.status = new PlayerStatus();
                this.isMoving = false;
                
                // å°„æ’ƒé–¢é€£ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                this.bullets = [];
                this.isAiming = false;
                this.lastShotTime = 0;
                this.shootCooldown = 500; // 0.5ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                
                // ç…§æº–ã®è¡¨ç¤º/éè¡¨ç¤º
                this.crosshair = document.getElementById('crosshair');
            }
            
            createCharacter() {
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚°ãƒ«ãƒ¼ãƒ—
                this.character = new THREE.Group();
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ä½“
                const bodyGeometry = new THREE.BoxGeometry(0.012, 0.024, 0.012);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 0.012;
                this.character.add(this.body);
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®é ­
                const headGeometry = new THREE.BoxGeometry(0.008, 0.008, 0.008);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.028;
                this.character.add(this.head);
                
                // è…•
                const armGeometry = new THREE.BoxGeometry(0.003, 0.012, 0.003);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                
                this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
                this.leftArm.position.set(-0.008, 0.012, 0);
                this.character.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
                this.rightArm.position.set(0.008, 0.012, 0);
                this.character.add(this.rightArm);
                
                // å½±ã‚’è½ã¨ã™
                this.character.traverse((object) => {
                    if (object instanceof THREE.Mesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                
                this.scene.add(this.character);
                this.character.position.set(0, 0, 0);
            }
            
            setupEventListeners() {
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // ã‚¿ãƒƒãƒå…¥åŠ›
                this.joystick.element.addEventListener('touchstart', (e) => this.onJoystickStart(e));
                this.joystick.element.addEventListener('touchmove', (e) => this.onJoystickMove(e));
                this.joystick.element.addEventListener('touchend', () => this.onJoystickEnd());
                
                // æ”»æ’ƒãƒœã‚¿ãƒ³
                document.getElementById('attack-button').addEventListener('touchstart', () => {
                    this.shoot();
                });
                
                // ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³
                document.getElementById('jump-button').addEventListener('touchstart', () => {
                    this.keys.jump = true;
                });
                document.getElementById('jump-button').addEventListener('touchend', () => {
                    this.keys.jump = false;
                });
                
                // ãƒãƒƒã‚°ãƒœã‚¿ãƒ³
                document.getElementById('bag-button').addEventListener('click', () => {
                    inventory.toggle();
                });
                
                // ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
                document.getElementById('camera-button').addEventListener('click', () => {
                    this.currentCamera = this.currentCamera === this.camera ? this.topDownCamera : this.camera;
                });
                
                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æ¥ç¶šã‚¤ãƒ™ãƒ³ãƒˆ
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad);
                    this.gamepad = e.gamepad;
                    this.gamepadConnected = true;
                });
                
                window.addEventListener('gamepaddisconnected', () => {
                    console.log('Gamepad disconnected');
                    this.gamepad = null;
                    this.gamepadConnected = false;
                });
            }
            
            onJoystickStart(event) {
                event.preventDefault();
                const touch = event.touches[0];
                const rect = this.joystick.element.getBoundingClientRect();
                
                this.joystick.active = true;
                this.joystick.startPosition.set(
                    touch.clientX - rect.left - rect.width / 2,
                    touch.clientY - rect.top - rect.height / 2
                );
                this.joystick.currentPosition.copy(this.joystick.startPosition);
                this.updateJoystickPosition();
            }
            
            onJoystickMove(event) {
                if (!this.joystick.active) return;
                event.preventDefault();
                
                const touch = event.touches[0];
                const rect = this.joystick.element.getBoundingClientRect();
                
                this.joystick.currentPosition.set(
                    touch.clientX - rect.left - rect.width / 2,
                    touch.clientY - rect.top - rect.height / 2
                );
                
                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç¯„å›²ã‚’åˆ¶é™
                const distance = this.joystick.currentPosition.length();
                const maxDistance = rect.width / 2 - 25; // ãƒãƒ–ã®åŠå¾„ã‚’è€ƒæ…®
                if (distance > maxDistance) {
                    this.joystick.currentPosition.normalize().multiplyScalar(maxDistance);
                }
                
                this.updateJoystickPosition();
            }
            
            onJoystickEnd() {
                this.joystick.active = false;
                this.joystick.currentPosition.set(0, 0);
                this.updateJoystickPosition();
            }
            
            updateJoystickPosition() {
                const knob = this.joystick.knob;
                const x = this.joystick.currentPosition.x;
                const y = this.joystick.currentPosition.y;
                knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
            }
            
            onKeyDown(event) {
                switch(event.code) {
                    case 'KeyW': this.keys.forward = true; break;
                    case 'KeyS': this.keys.backward = true; break;
                    case 'KeyA': this.keys.left = true; break;
                    case 'KeyD': this.keys.right = true; break;
                    case 'Space': 
                        this.keys.jump = true;
                        this.shoot(); // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å°„æ’ƒ
                        break;
                }
            }
            
            onKeyUp(event) {
                switch(event.code) {
                    case 'KeyW': this.keys.forward = false; break;
                    case 'KeyS': this.keys.backward = false; break;
                    case 'KeyA': this.keys.left = false; break;
                    case 'KeyD': this.keys.right = false; break;
                    case 'Space': this.keys.jump = false; break;
                }
            }
            
            update() {
                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
                if (this.gamepadConnected) {
                    const gamepads = navigator.getGamepads();
                    this.gamepad = gamepads[this.gamepad.index];
                    
                    // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å…¥åŠ›
                    const leftStickX = this.gamepad.axes[0];
                    const leftStickY = this.gamepad.axes[1];
                    
                    // ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³ï¼ˆå°ã•ãªå…¥åŠ›ã‚’ç„¡è¦–ï¼‰
                    const deadzone = 0.1;
                    if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                        this.joystick.currentPosition.x = leftStickX * 75;
                        this.joystick.currentPosition.y = leftStickY * 75;
                        this.joystick.active = true;
                    } else {
                        this.joystick.active = false;
                        this.joystick.currentPosition.set(0, 0);
                    }
                    
                    // Aãƒœã‚¿ãƒ³ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ï¼‰
                    this.keys.jump = this.gamepad.buttons[0].pressed;
                    
                    // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ä½ç½®ã‚’æ›´æ–°
                    this.updateJoystickPosition();
                }
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å›è»¢ï¼ˆå›ºå®šï¼‰
                this.character.rotation.y = 0;
                
                // ç§»å‹•æ–¹å‘ã®è¨ˆç®—
                const moveDirection = new THREE.Vector3();
                
                if (this.joystick.active) {
                    // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å…¥åŠ›ã‚’ä½¿ç”¨
                    moveDirection.x = this.joystick.currentPosition.x / 75;
                    moveDirection.z = this.joystick.currentPosition.y / 75;
                } else {
                    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®å…¥åŠ›ã‚’ä½¿ç”¨
                    if (this.keys.forward) moveDirection.z -= 1;
                    if (this.keys.backward) moveDirection.z += 1;
                    if (this.keys.left) moveDirection.x -= 1;
                    if (this.keys.right) moveDirection.x += 1;
                }
                
                // ç§»å‹•æ–¹å‘ã‚’ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å‘ãã«åˆã‚ã›ã¦å›è»¢ï¼ˆå›ºå®šæ–¹å‘ï¼‰
                moveDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
                
                // é‡åŠ›ã®é©ç”¨
                this.velocity.y -= this.gravity;
                
                // åœ°é¢ã¨ã®è¡çªåˆ¤å®š
                this.raycaster.set(
                    this.character.position.clone().add(new THREE.Vector3(0, 0.1, 0)),
                    new THREE.Vector3(0, -1, 0)
                );
                const groundIntersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // åœ°é¢ã¨ã®è¡çªåˆ¤å®šï¼ˆåœ°é¢ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
                const groundCheck = groundIntersects.find(obj => 
                    obj.object.geometry.type === 'PlaneGeometry'
                );
                
                if (groundCheck && groundCheck.distance < 0.2) {
                    this.isGrounded = true;
                    this.velocity.y = Math.max(0, this.velocity.y);
                    this.character.position.y = groundCheck.point.y;
                } else {
                    this.isGrounded = false;
                }
                
                // ç§»å‹•ã®é©ç”¨ï¼ˆè¡çªåˆ¤å®šä»˜ãï¼‰
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    const newPosition = this.character.position.clone().add(
                        moveDirection.multiplyScalar(this.moveSpeed)
                    );
                    
                    // ç§»å‹•å‰ã«è¡çªãƒã‚§ãƒƒã‚¯
                    const canMove = !this.checkCollision(
                        newPosition.clone().add(new THREE.Vector3(0, 0.1, 0)),
                        moveDirection
                    );
                    
                    if (canMove) {
                        this.character.position.x = newPosition.x;
                        this.character.position.z = newPosition.z;
                        
                        // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        const walkCycle = Date.now() * 0.01;
                        this.leftArm.rotation.x = Math.sin(walkCycle) * 0.5;
                        this.rightArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
                    }
                } else {
                    // é™æ­¢æ™‚ã¯è…•ã‚’å…ƒã®ä½ç½®ã«
                    this.leftArm.rotation.x = 0;
                    this.rightArm.rotation.x = 0;
                }
                
                // å‚ç›´æ–¹å‘ã®ç§»å‹•ï¼ˆé‡åŠ›ã¨ã‚¸ãƒ£ãƒ³ãƒ—ï¼‰
                if (!this.isGrounded) {
                    this.character.position.y += this.velocity.y;
                }
                
                // ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
                if (this.keys.jump && this.isGrounded) {
                    this.velocity.y = this.jumpForce;
                    this.isGrounded = false;
                }
                
                // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã¨å›è»¢ã®æ›´æ–°
                if (this.currentCamera === this.camera) {
                    // é€šå¸¸ã®TPSã‚«ãƒ¡ãƒ©
                    const cameraOffset = new THREE.Vector3(0, 0.1, 0.3);
                    this.camera.position.copy(this.character.position).add(cameraOffset);
                    this.camera.lookAt(this.character.position);
                } else {
                    // æ–œã‚ä¸Šã‹ã‚‰ã®è¦‹ä¸‹ã‚ã—ã‚«ãƒ¡ãƒ©
                    this.topDownCamera.position.copy(this.character.position).add(new THREE.Vector3(0, 1, 1));
                    this.topDownCamera.lookAt(this.character.position);
                }
                
                // ç§»å‹•çŠ¶æ…‹ã®æ›´æ–°
                this.isMoving = moveDirection.length() > 0;
                
                // ç¾åœ¨ã®ãƒã‚¤ã‚ªãƒ¼ãƒ ã‚’å–å¾—
                const currentBiome = cityMap.getBiome(this.character.position.x, this.character.position.z);
                
                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®æ›´æ–°
                this.status.update(this.isMoving, currentBiome);
                
                // å¼¾ä¸¸ã®æ›´æ–°
                this.bullets = this.bullets.filter(bullet => !bullet.update());
                
                // ç…§æº–ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ç§»å‹•é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹
                if (this.isAiming) {
                    this.moveSpeed = 0.005; // é€šå¸¸ã®åŠåˆ†
                } else {
                    this.moveSpeed = 0.01;
                }
                
                // ã‚¢ã‚¤ãƒ†ãƒ ã®æ›´æ–°
                itemManager.update(this.character.position);
                
                // ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è¡çªåˆ¤å®š
                const collectedItem = itemManager.checkCollisions(this.character.position);
                if (collectedItem) {
                    inventory.addItem(collectedItem);
                }
            }
            
            // è¡çªåˆ¤å®šã‚’è¡Œã†ãƒ¡ã‚½ãƒƒãƒ‰
            checkCollision(position, direction) {
                this.raycaster.set(position, direction);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                // å»ºç‰©ã¨åœ°é¢ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
                const validObjects = intersects.filter(obj => 
                    obj.object.type === 'Mesh' && 
                    (obj.object.geometry.type === 'BoxGeometry' || 
                     obj.object.geometry.type === 'PlaneGeometry')
                );
                
                if (validObjects.length > 0 && validObjects[0].distance < this.collisionDistance) {
                    return true;
                }
                return false;
            }
            
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime < this.shootCooldown) return;
                
                this.lastShotTime = currentTime;
                
                // å¼¾ä¸¸ã®ç”Ÿæˆä½ç½®ï¼ˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æ­£é¢ï¼‰
                const bulletPosition = this.character.position.clone();
                bulletPosition.y += 0.02; // å°‘ã—ä¸Šã«èª¿æ•´
                
                // ç™ºå°„æ–¹å‘ï¼ˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å‘ãï¼‰
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.character.quaternion);
                
                // å¼¾ä¸¸ã‚’ç”Ÿæˆ
                const bullet = new Bullet(this.scene, bulletPosition, direction);
                this.bullets.push(bullet);
            }
        }
        
        // ã‚¾ãƒ³ãƒ“ã‚¯ãƒ©ã‚¹
        class Zombie {
            constructor(scene, position) {
                this.scene = scene;
                this.speed = 0.03;  // é€Ÿåº¦ã‚’0.03ã‹ã‚‰0.01ã«æ¸›å°‘
                this.detectionRadius = 10;
                this.attackRadius = 1;
                this.health = 100;
                this.state = 'wander'; // wander, chase
                this.wanderDirection = new THREE.Vector3();
                this.wanderTimer = 0;
                this.wanderInterval = 2000; // 2ç§’ã”ã¨ã«æ–¹å‘è»¢æ›
                this.lastWanderTime = Date.now();
                this.isDead = false;
                
                // ã‚¾ãƒ³ãƒ“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
                this.createMesh();
                this.mesh.position.copy(position);
                scene.add(this.mesh);
            }
            
            createMesh() {
                this.mesh = new THREE.Group();
                
                // ä½“
                const bodyGeometry = new THREE.BoxGeometry(0.012, 0.024, 0.012);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.position.y = 0.012;
                this.mesh.add(this.body);
                
                // é ­
                const headGeometry = new THREE.BoxGeometry(0.008, 0.008, 0.008);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0x999999 });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.028;
                this.mesh.add(this.head);
                
                // è…•
                const armGeometry = new THREE.BoxGeometry(0.003, 0.012, 0.003);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                
                this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
                this.leftArm.position.set(-0.008, 0.012, 0);
                this.mesh.add(this.leftArm);
                
                this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
                this.rightArm.position.set(0.008, 0.012, 0);
                this.mesh.add(this.rightArm);
                
                // å½±ã‚’è½ã¨ã™
                this.mesh.traverse((object) => {
                    if (object instanceof THREE.Mesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
            }
            
            update(playerPosition) {
                const distanceToPlayer = this.mesh.position.distanceTo(playerPosition);
                
                if (distanceToPlayer < this.attackRadius) {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                    characterController.status.takeDamage(1);
                }
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã«å¿œã˜ã¦çŠ¶æ…‹ã‚’æ›´æ–°
                if (distanceToPlayer < this.detectionRadius) {
                    this.state = 'chase';
                } else {
                    this.state = 'wander';
                }
                
                // çŠ¶æ…‹ã«å¿œã˜ãŸè¡Œå‹•
                if (this.state === 'chase') {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„ã‹ã‘ã‚‹
                    const direction = new THREE.Vector3()
                        .subVectors(playerPosition, this.mesh.position)
                        .normalize();
                    
                    // ç§»å‹•å‰ã®ä½ç½®ã‚’ä¿å­˜
                    const oldPosition = this.mesh.position.clone();
                    
                    // ç§»å‹•ã‚’è©¦ã¿ã‚‹
                    this.mesh.position.add(direction.multiplyScalar(this.speed));
                    
                    // è¡çªåˆ¤å®š
                    if (this.checkCollision()) {
                        // è¡çªã—ãŸå ´åˆã¯å…ƒã®ä½ç½®ã«æˆ»ã™
                        this.mesh.position.copy(oldPosition);
                    }
                    
                    this.mesh.lookAt(playerPosition);
                    
                    // è…•ã‚’æŒ¯ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.leftArm.rotation.x = Math.sin(Date.now() * 0.01) * 0.5;
                    this.rightArm.rotation.x = Math.sin(Date.now() * 0.01 + Math.PI) * 0.5;
                } else {
                    // ãƒ©ãƒ³ãƒ€ãƒ ã«å¾˜å¾Š
                    if (Date.now() - this.lastWanderTime > this.wanderInterval) {
                        this.wanderDirection.set(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                        this.lastWanderTime = Date.now();
                    }
                    
                    // ç§»å‹•å‰ã®ä½ç½®ã‚’ä¿å­˜
                    const oldPosition = this.mesh.position.clone();
                    
                    // ç§»å‹•ã‚’è©¦ã¿ã‚‹
                    this.mesh.position.add(this.wanderDirection.multiplyScalar(this.speed * 0.5));
                    
                    // è¡çªåˆ¤å®š
                    if (this.checkCollision()) {
                        // è¡çªã—ãŸå ´åˆã¯å…ƒã®ä½ç½®ã«æˆ»ã™
                        this.mesh.position.copy(oldPosition);
                        // æ–°ã—ã„æ–¹å‘ã‚’è¨­å®š
                        this.wanderDirection.set(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                    }
                    
                    this.mesh.lookAt(
                        this.mesh.position.clone().add(this.wanderDirection)
                    );
                    
                    // è…•ã‚’å°‘ã—å‹•ã‹ã™
                    this.leftArm.rotation.x = Math.sin(Date.now() * 0.005) * 0.2;
                    this.rightArm.rotation.x = Math.sin(Date.now() * 0.005 + Math.PI) * 0.2;
                }
            }
            
            // è¡çªåˆ¤å®šï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
            checkCollision() {
                const raycaster = new THREE.Raycaster();
                const directions = [
                    new THREE.Vector3(1, 0, 0),   // å³
                    new THREE.Vector3(-1, 0, 0),  // å·¦
                    new THREE.Vector3(0, 0, 1),   // å‰
                    new THREE.Vector3(0, 0, -1)   // å¾Œ
                ];
                
                // è¿‘ãã®å»ºç‰©ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(this.mesh.position);
                        return distance < 3; // 3å˜ä½ä»¥å†…ã®å»ºç‰©ã®ã¿ãƒã‚§ãƒƒã‚¯
                    }
                    return false;
                });
                
                for (const direction of directions) {
                    raycaster.set(this.mesh.position, direction);
                    const intersects = raycaster.intersectObjects(nearbyObjects, true);
                    
                    for (const intersect of intersects) {
                        if (intersect.object.geometry.type === 'BoxGeometry' && 
                            intersect.distance < 0.1) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            remove() {
                this.scene.remove(this.mesh);
            }
            
            takeDamage() {
                if (!this.isDead) {
                    this.isDead = true;
                    this.remove();
                }
            }
        }
        
        // å¼¾ä¸¸ã‚¯ãƒ©ã‚¹
        class Bullet {
            constructor(scene, position, direction) {
                this.scene = scene;
                this.speed = 0.5;
                this.lifetime = 2000; // 2ç§’å¾Œã«æ¶ˆæ»…
                this.createdAt = Date.now();
                
                // å¼¾ä¸¸ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
                const geometry = new THREE.SphereGeometry(0.005, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.castShadow = true;
                
                // ç§»å‹•æ–¹å‘ã‚’è¨­å®š
                this.direction = direction.normalize();
                
                scene.add(this.mesh);
            }
            
            update() {
                // å¼¾ä¸¸ã‚’ç§»å‹•
                this.mesh.position.add(this.direction.multiplyScalar(this.speed));
                
                // å¯¿å‘½ãŒå°½ããŸã‚‰å‰Šé™¤
                if (Date.now() - this.createdAt > this.lifetime) {
                    this.remove();
                    return true;
                }
                return false;
            }
            
            remove() {
                this.scene.remove(this.mesh);
            }
        }
        
        // ã‚¾ãƒ³ãƒ“ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹
        class ZombieManager {
            constructor(scene) {
                this.scene = scene;
                this.zombies = new Set();
                this.spawnRadius = 2;
                this.despawnRadius = 3;
                this.maxZombies =  1;
                this.spawnInterval = 5000; // 5ç§’ã”ã¨ã«ã‚¹ãƒãƒ¼ãƒ³
                this.lastSpawnTime = Date.now();
                this.currentZombieIndex = 0; // ç¾åœ¨å‡¦ç†ä¸­ã®ã‚¾ãƒ³ãƒ“ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                this.zombiesArray = []; // ã‚¾ãƒ³ãƒ“ã®é…åˆ—ï¼ˆé †æ¬¡å‡¦ç†ç”¨ï¼‰
            }
            
            update(playerPosition) {
                // ã‚¾ãƒ³ãƒ“ã®é…åˆ—ã‚’æ›´æ–°ï¼ˆSetã‹ã‚‰é…åˆ—ã¸ï¼‰
                this.zombiesArray = Array.from(this.zombies);
                
                // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã§å‡¦ç†ã™ã‚‹ã‚¾ãƒ³ãƒ“ã®æ•°ï¼ˆå…¨ä½“ã®1/4ã‚’å‡¦ç†ï¼‰
                const zombiesPerFrame = Math.max(1, Math.ceil(this.zombiesArray.length / 4));
                
                // ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å‡¦ç†ã™ã‚‹ã‚¾ãƒ³ãƒ“ã®ç¯„å›²ã‚’è¨ˆç®—
                const startIndex = this.currentZombieIndex;
                const endIndex = Math.min(startIndex + zombiesPerFrame, this.zombiesArray.length);
                
                // æŒ‡å®šç¯„å›²ã®ã‚¾ãƒ³ãƒ“ã‚’å‡¦ç†
                for (let i = startIndex; i < endIndex; i++) {
                    const zombie = this.zombiesArray[i];
                    const distanceToPlayer = zombie.mesh.position.distanceTo(playerPosition);
                    
                    if (distanceToPlayer > this.despawnRadius) {
                        zombie.remove();
                        this.zombies.delete(zombie);
                    } else {
                        zombie.update(playerPosition);
                    }
                }
                
                // æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                this.currentZombieIndex = endIndex >= this.zombiesArray.length ? 0 : endIndex;
            }
            
            spawnZombie(playerPosition) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ä¸€å®šè·é›¢é›¢ã‚ŒãŸä½ç½®ã«ã‚¹ãƒãƒ¼ãƒ³
                const angle = Math.random() * Math.PI * 2;
                const spawnPosition = new THREE.Vector3(
                    playerPosition.x + Math.cos(angle) * this.spawnRadius,
                    0.1,
                    playerPosition.z + Math.sin(angle) * this.spawnRadius
                );
                
                // ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ãŒéšœå®³ç‰©ã¨é‡ãªã£ã¦ã„ãªã„ã‹ç¢ºèª
                if (!this.checkSpawnCollision(spawnPosition)) {
                    const zombie = new Zombie(this.scene, spawnPosition);
                    this.zombies.add(zombie);
                }
            }
            
            // ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã®è¡çªåˆ¤å®šï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
            checkSpawnCollision(position) {
                const raycaster = new THREE.Raycaster();
                raycaster.set(position, new THREE.Vector3(0, -1, 0));
                
                // è¿‘ãã®å»ºç‰©ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
                const nearbyObjects = this.scene.children.filter(obj => {
                    if (obj.type === 'Group') {
                        const distance = obj.position.distanceTo(position);
                        return distance < 5; // 5å˜ä½ä»¥å†…ã®å»ºç‰©ã®ã¿ãƒã‚§ãƒƒã‚¯
                    }
                    return false;
                });
                
                const intersects = raycaster.intersectObjects(nearbyObjects, true);
                
                // å»ºç‰©ã‚„éšœå®³ç‰©ã¨ã®è¡çªã‚’ãƒã‚§ãƒƒã‚¯
                for (const intersect of intersects) {
                    if (intersect.object.geometry.type === 'BoxGeometry' && 
                        intersect.distance < 0.1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            spawnInitialZombies(playerPosition) {
                // æœ€å¤§æ•°ã®ã‚¾ãƒ³ãƒ“ã‚’ä¸€åº¦ã«ç”Ÿæˆ
                for (let i = 0; i < this.maxZombies; i++) {
                    this.spawnZombie(playerPosition);
                }
            }
            
            clear() {
                for (const zombie of this.zombies) {
                    zombie.remove();
                }
                this.zombies.clear();
                this.zombiesArray = [];
                this.currentZombieIndex = 0;
            }
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¯ãƒ©ã‚¹
        class PlayerStatus {
            constructor() {
                this.maxValue = 100;
                this.health = this.maxValue;
                this.hunger = this.maxValue;
                this.thirst = this.maxValue;
                this.bleeding = this.maxValue;
                this.hygiene = this.maxValue;
                this.temperature = this.maxValue;
                
                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ¸›å°‘ã®ã‚¿ã‚¤ãƒãƒ¼
                this.lastUpdateTime = Date.now();
                this.updateInterval = 1000; // 1ç§’ã”ã¨ã«æ›´æ–°
                
                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ¸›å°‘ç‡
                this.decreaseRates = {
                    hunger: 0.1,      // ç©ºè…¹åº¦ã®æ¸›å°‘ç‡
                    thirst: 0.15,     // å–‰ã®æ¸‡ãã®æ¸›å°‘ç‡
                    hygiene: 0.05,    // è¡›ç”ŸçŠ¶æ…‹ã®æ¸›å°‘ç‡
                    temperature: 0.02    // ä½“æ¸©ã®æ¸›å°‘ç‡
                };
            }
            
            update(isMoving, currentBiome) {
                const currentTime = Date.now();
                if (currentTime - this.lastUpdateTime >= this.updateInterval) {
                    this.lastUpdateTime = currentTime;
                    
                    // ç§»å‹•ä¸­ã¯ç©ºè…¹ã¨å–‰ã®æ¸‡ããŒæ¸›å°‘
                    if (isMoving) {
                        this.hunger = Math.max(0, this.hunger - this.decreaseRates.hunger);
                        this.thirst = Math.max(0, this.thirst - this.decreaseRates.thirst);
                    }
                    
                    // æ£®ã®ä¸­ã§ã¯è¡›ç”ŸçŠ¶æ…‹ãŒæ¸›å°‘
                    if (currentBiome.name === "æ£®æ—") {
                        this.hygiene = Math.max(0, this.hygiene - this.decreaseRates.hygiene);
                    }
                    
                    // ä½“æ¸©ã®è‡ªç„¶æ¸›å°‘
                    this.temperature = Math.max(0, this.temperature - this.decreaseRates.temperature);
                    
                    // å‡ºè¡€ã€ç©ºè…¹ã€å–‰ã®æ¸‡ãã€è¡›ç”ŸçŠ¶æ…‹ã€ä½“æ¸©ãŒ0ã®å ´åˆã€ä½“åŠ›ãŒæ¸›å°‘
                    if (this.bleeding <= 0 || this.hunger <= 0 || this.thirst <= 0 || 
                        this.hygiene <= 0 || this.temperature <= 0) {
                        this.health = Math.max(0, this.health - 0.5);
                    }
                    
                    // ä½“åŠ›ãŒ0ã«ãªã£ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                    if (this.health <= 0) {
                        this.gameOver();
                    }
                    
                    this.updateUI();
                }
            }
            
            takeDamage(amount) {
                this.bleeding = Math.max(0, this.bleeding - amount);
                this.updateUI();
            }
            
            updateUI() {
                document.getElementById('health-fill').style.width = `${this.health}%`;
                document.getElementById('hunger-fill').style.width = `${this.hunger}%`;
                document.getElementById('thirst-fill').style.width = `${this.thirst}%`;
                document.getElementById('bleeding-fill').style.width = `${this.bleeding}%`;
                document.getElementById('hygiene-fill').style.width = `${this.hygiene}%`;
                document.getElementById('temperature-fill').style.width = `${this.temperature}%`;
            }
            
            gameOver() {
                document.getElementById('game-over').style.display = 'block';
            }
        }
        
        // ãƒãƒƒãƒ—ã®åˆæœŸç”Ÿæˆ
        let cityMap = new CityMap(config, scene);
        let mapMeshes = cityMap.generate();
        scene.add(mapMeshes);
        
        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ–
        const characterController = new CharacterController(scene, camera, topDownCamera);
        
        // ã‚¾ãƒ³ãƒ“ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–ã¨åˆæœŸã‚¾ãƒ³ãƒ“ã®ç”Ÿæˆ
        const zombieManager = new ZombieManager(scene);
        zombieManager.spawnInitialZombies(characterController.character.position);
        
        // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        class TimeSystem {
            constructor() {
                this.hour = 9; // é–‹å§‹æ™‚é–“ï¼ˆ6æ™‚ï¼‰
                this.minute = 0;
                //this.timeScale = 60; // 1ç§’ã§1åˆ†é€²ã‚€
                this.timeScale = 1; // 1ç§’ã§1åˆ†é€²ã‚€
                this.lastUpdate = Date.now();
                
                // æ™‚é–“å¸¯ã”ã¨ã®è‰²è¨­å®š
                this.timeColors = {
                    dawn: { sky: 0xff7e50, ambient: 0x404040 }, // å¤œæ˜ã‘ (5-7æ™‚)
                    day: { sky: 0x87ceeb, ambient: 0xffffff },  // æ—¥ä¸­ (7-17æ™‚)
                    dusk: { sky: 0xff7e50, ambient: 0x404040 }, // å¤•æš®ã‚Œ (17-19æ™‚)
                    night: { sky: 0x000033, ambient: 0x202020 } // å¤œ (19-5æ™‚)
                };
                
                // å¤ªé™½ã®ä½ç½®è¨ˆç®—ç”¨
                this.sunRadius = 100;
                this.sunHeight = 50;
            }
            
            update() {
                const currentTime = Date.now();
                const deltaTime = (currentTime - this.lastUpdate) / 1000;
                this.lastUpdate = currentTime;
                
                // æ™‚é–“ã®æ›´æ–°
                this.minute += deltaTime * this.timeScale;
                if (this.minute >= 60) {
                    this.hour = (this.hour + Math.floor(this.minute / 60)) % 24;
                    this.minute = this.minute % 60;
                }
                
                // UIã®æ›´æ–°
                document.getElementById('current-time').textContent = 
                    `æ™‚é–“: ${String(this.hour).padStart(2, '0')}:${String(Math.floor(this.minute)).padStart(2, '0')}`;
                
                return this.getTimeOfDay();
            }
            
            getTimeOfDay() {
                if (this.hour >= 5 && this.hour < 7) return 'dawn';
                if (this.hour >= 7 && this.hour < 17) return 'day';
                if (this.hour >= 17 && this.hour < 19) return 'dusk';
                return 'night';
            }
            
            getSunPosition() {
                const timeOfDay = this.getTimeOfDay();
                let sunAngle;
                
                switch(timeOfDay) {
                    case 'dawn':
                        sunAngle = (this.hour - 5 + this.minute / 60) * Math.PI / 2;
                        break;
                    case 'day':
                        sunAngle = Math.PI / 2 + (this.hour - 7 + this.minute / 60) * Math.PI / 10;
                        break;
                    case 'dusk':
                        sunAngle = Math.PI + (this.hour - 17 + this.minute / 60) * Math.PI / 2;
                        break;
                    case 'night':
                        sunAngle = Math.PI + (this.hour - 19 + this.minute / 60) * Math.PI / 10;
                        break;
                }
                
                return {
                    x: Math.cos(sunAngle) * this.sunRadius,
                    y: Math.sin(sunAngle) * this.sunHeight,
                    z: Math.sin(sunAngle) * this.sunRadius
                };
            }
            
            getSkyColor() {
                return this.timeColors[this.getTimeOfDay()].sky;
            }
            
            getAmbientLight() {
                return this.timeColors[this.getTimeOfDay()].ambient;
            }
        }
        
        // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
        const timeSystem = new TimeSystem();
        
        // å¤ªé™½ã®ä½œæˆ
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            
            // æ™‚é–“ã®æ›´æ–°
            const timeOfDay = timeSystem.update();
            
            // å¤ªé™½ã®ä½ç½®æ›´æ–°
            const sunPos = timeSystem.getSunPosition();
            sun.position.set(sunPos.x, sunPos.y, sunPos.z);
            
            // ç©ºã®è‰²ã‚’æ›´æ–°
            scene.background = new THREE.Color(timeSystem.getSkyColor());
            
            // ç’°å¢ƒå…‰ã‚’æ›´æ–°
            ambientLight.color.setHex(timeSystem.getAmbientLight());
            
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ä½ç½®ã«åŸºã¥ã„ã¦æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
            const characterPos = characterController.character.position;
            const sectionX = Math.floor(characterPos.x / config.width);
            const sectionZ = Math.floor(characterPos.z / config.height);
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®æ›´æ–°
            document.getElementById('position').textContent = 
                `ä½ç½®: X: ${characterPos.x.toFixed(2)}, Y: ${characterPos.y.toFixed(2)}, Z: ${characterPos.z.toFixed(2)}`;
            
            // ãƒã‚¤ã‚ªãƒ¼ãƒ æƒ…å ±ã®æ›´æ–°
            const currentBiome = cityMap.getBiome(characterPos.x, characterPos.z);
            document.getElementById('biome').textContent = `ãƒã‚¤ã‚ªãƒ¼ãƒ : ${currentBiome.name}`;
            
            // ã‚¾ãƒ³ãƒ“ã®æ•°ã‚’è¡¨ç¤º
            document.getElementById('zombie-count').textContent = `ã‚¾ãƒ³ãƒ“æ•°: ${zombieManager.zombies.size}`;
            
            // å‘¨å›²ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
            for (let x = sectionX - 1; x <= sectionX + 1; x++) {
                for (let z = sectionZ - 1; z <= sectionZ + 1; z++) {
                    if (!cityMap.hasSection(x * config.width, z * config.height)) {
                        cityMap.generateSection(x, z);
                    }
                }
            }
            
            // ã‚¾ãƒ³ãƒ“ã®æ›´æ–°
            zombieManager.update(characterPos);
            
            characterController.update();
            renderer.render(scene, characterController.currentCamera);
            
            // å¼¾ä¸¸ã¨ã‚¾ãƒ³ãƒ“ã®è¡çªåˆ¤å®š
            checkBulletCollisions(characterController.bullets, zombieManager.zombiesArray);
        }
        
        animate();
        
        // è¡çªåˆ¤å®šã‚’è¿½åŠ 
        function checkBulletCollisions(bullets, zombies) {
            for (const bullet of bullets) {
                for (const zombie of zombies) {
                    if (zombie.isDead) continue;
                    
                    const distance = bullet.mesh.position.distanceTo(zombie.mesh.position);
                    if (distance < 0.1) { // è¡çªåˆ¤å®šã®è·é›¢
                        zombie.takeDamage();
                        bullet.remove();
                        break;
                    }
                }
            }
        }
    </script>
</body>
</html>