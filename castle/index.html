<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR城防衛ゲーム</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            display: block;
            pointer-events: none;
        }
        #timer, #score {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 10px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: red;
        }
        #crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #crosshair::after {
            height: 100%;
            width: 2px;
            left: 50%;
            transform: translateX(-50%);
        }
        #fireButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 70px;
            height: 70px;
            background-color: #FF3333;
            color: white;
            font-weight: bold;
            border: none;
            border-radius: 50%;
            display: none;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        #fireButton:active {
            background-color: #CC0000;
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="info">
        <span id="timer">残り時間: 30秒</span>
        <span id="score">スコア: 0</span>
    </div>
    <div id="crosshair"></div>
    <button id="startButton">ゲームを開始</button>
    <button id="calibrateButton" style="display: none; position: absolute; bottom: 20px; right: 20px; padding: 10px; background-color: #007BFF; color: white; border: none; border-radius: 5px; z-index: 100;">位置合わせ</button>
    <button id="fireButton">発射</button>
    <div id="gameOver">
        <h2>ゲーム終了!</h2>
        <p>あなたのスコア: <span id="finalScore">0</span></p>
        <button id="restartButton">もう一度プレイ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // ============================================================
        // GLTFモデル設定
        // ============================================================
        // モデルのURL設定（実際のプロジェクトでは適切なURLに変更してください）
        const MODEL_URLS = {
            soldier: '../glb/8ab8b22e643d_Sengoku_period_in_Japan__sol_0_glb.glb',   // 通常兵士
            archer: '../glb/8ab8b22e643d_Sengoku_period_in_Japan__sol_0_glb.glb',     // 弓兵
            knight: '../glb/8ab8b22e643d_Sengoku_period_in_Japan__sol_0_glb.glb'      // 重装兵
        };
        
        // モデル読み込み用変数
        let gltfLoader;
        let modelCache = {}; // 一度読み込んだモデルをキャッシュする

        // モデル読み込み関数
        function loadModel(modelType) {
            return new Promise((resolve, reject) => {
                // すでにキャッシュにある場合はそれを返す
                if (modelCache[modelType]) {
                    resolve(modelCache[modelType].clone());
                    return;
                }
                
                // モデルURLの取得
                const modelUrl = MODEL_URLS[modelType];
                if (!modelUrl) {
                    reject(new Error(`モデルタイプ "${modelType}" のURLが見つかりません`));
                    return;
                }
                
                // モデルの読み込み
                gltfLoader.load(
                    modelUrl,
                    (gltf) => {
                        const model = gltf.scene;
                        // スケールの調整
                        model.scale.set(16, 16, 16);
                        // 回転の調整（必要に応じて）
                        model.rotation.y = Math.PI;
                        
                        // モデルにシャドウを設定
                        model.traverse(function(node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                                
                                // マテリアルの明るさを調整
                                if (node.material) {
                                    // 単一のマテリアルの場合
                                    adjustMaterial(node.material);
                                } else if (node.materials) {
                                    // 複数のマテリアルの場合
                                    node.materials.forEach(material => adjustMaterial(material));
                                }
                            }
                        });
                        
                        // アニメーションの設定（モデルにアニメーションがある場合）
                        if (gltf.animations && gltf.animations.length > 0) {
                            model.animations = gltf.animations;
                        }
                        
                        // キャッシュに保存
                        modelCache[modelType] = model;
                        
                        // クローンを返す
                        resolve(model.clone());
                    },
                    (xhr) => {
                        // 読み込み進捗（デバッグ用）
                        console.log(`${modelType}モデル読み込み: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
                    },
                    (error) => {
                        console.error(`モデル読み込みエラー: ${error.message}`);
                        reject(error);
                    }
                );
            });
        }
        
        // マテリアルを明るく調整する関数
        function adjustMaterial(material) {
            if (!material) return;
            
            // 明るさを上げる
            if (material.color) {
                // 色の明るさを少し上げる
                const hsl = {};
                material.color.getHSL(hsl);
                hsl.l = Math.min(1.0, hsl.l * 1.2); // 明るさを20%増加
                material.color.setHSL(hsl.h, hsl.s, hsl.l);
            }
            
            // 反射率を上げる
            if (material.reflectivity !== undefined) {
                material.reflectivity = Math.min(1.0, material.reflectivity * 1.3);
            }
            
            // 光沢を調整
            if (material.shininess !== undefined) {
                material.shininess = Math.min(100, material.shininess * 1.5);
            }
            
            // エミッシブを追加して自己発光させる
            if (!material.emissive) {
                material.emissive = new THREE.Color(0x222222);
            } else {
                // 既存のエミッシブ値を少し強くする
                material.emissive.multiplyScalar(1.2);
            }
            
            // マテリアルの更新フラグ
            material.needsUpdate = true;
        }
        
        // モデルのフォールバック（モデル読み込み失敗時に使用する簡易ジオメトリ）
        function createFallbackEnemy(enemyType) {
            let enemyGeometry, enemyMaterial, enemy;
            
            switch (enemyType) {
                case 'soldier': // 通常兵士
                    enemyGeometry = new THREE.BoxGeometry(3, 6, 3);
                    enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                    break;
                case 'archer': // 弓兵
                    enemyGeometry = new THREE.BoxGeometry(2, 7, 2);
                    enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff9900 });
                    break;
                case 'knight': // 重装兵
                    enemyGeometry = new THREE.BoxGeometry(5, 8, 5);
                    enemyMaterial = new THREE.MeshLambertMaterial({ color: 0x990000 });
                    break;
                default:
                    enemyGeometry = new THREE.BoxGeometry(3, 6, 3);
                    enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            }
            
            enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            
            // 頭部の追加
            const headGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcccc });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4;
            enemy.add(head);
            
            return enemy;
        }
        
        // ============================================================
        // ゲーム変数
        // ============================================================
        // ゲーム変数
        let camera, scene, renderer;
        let castle, enemies = [];
        let bullets = []; // 弾丸の配列
        let effects = []; // エフェクトの配列
        let clock = new THREE.Clock();
        let gameTime = 30; // 30秒のゲーム時間
        let score = 0;
        let isGameRunning = false;
        let raycaster, mouse;
        let mixers = []; // アニメーションミキサー
        
        // センサー調整用の変数
        let initialBeta = 0;
        let initialGamma = 0;
        let initialAlpha = 0;
        let isSensorCalibrated = false;
        let deviceHasOrientation = false; // デバイスが方向センサーを持っているかどうか

        // サウンド効果
        const sounds = {
            gunshot: new Howl({
                src: ['https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js'], // ダミーURL（実際はプロジェクトに音源を追加する必要があります）
                volume: 0.5
            }),
            enemyDeath: new Howl({
                src: ['https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js'], // ダミーURL
                volume: 0.5
            }),
            gameStart: new Howl({
                src: ['https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js'], // ダミーURL
                volume: 0.5
            }),
            gameOver: new Howl({
                src: ['https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js'], // ダミーURL
                volume: 0.7
            })
        };

        // ゲーム初期化
        function init() {
            // シーンの作成
            scene = new THREE.Scene();
            
            // カメラの設定
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 0); // 天守閣の頂上を想定
            
            // レンダラーの設定
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // 光源の追加
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // 環境光を強くする
            scene.add(ambientLight);
            
            // メインの指向性ライト
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 強度を上げる
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true; // 影を有効化
            scene.add(directionalLight);
            
            // 補助ライト（反対側からの柔らかい光）
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-1, 0.5, -1);
            scene.add(fillLight);
            
            // 下からの光（モデルの底部も見えるように）
            const bottomLight = new THREE.DirectionalLight(0xffffee, 0.4);
            bottomLight.position.set(0, -1, 0);
            scene.add(bottomLight);
            
            // プレイヤー（カメラ）の位置にスポットライト
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.copy(camera.position);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.1;
            spotLight.decay = 2;
            spotLight.distance = 200;
            camera.add(spotLight); // カメラに追加して一緒に動くようにする
            scene.add(camera); // カメラをシーンに追加
            
            // GLTFローダーの初期化
            gltfLoader = new THREE.GLTFLoader();
            
            // 城の作成
            createCastle();
            
            // レイキャスターとマウス初期化
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // イベントリスナー
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onMouseClick, false);
            
            // デバイスの向きの変化を検知 - 権限が必要な場合に対応
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ では権限リクエストが必要
                document.getElementById('startButton').addEventListener('click', () => {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', onDeviceOrientation, false);
                                startGame();
                            } else {
                                alert('動きを検知するには方向センサーへのアクセスを許可してください。');
                            }
                        })
                        .catch(console.error);
                });
            } else {
                // 通常のデバイス（Android など）
                window.addEventListener('deviceorientation', onDeviceOrientation, false);
                document.getElementById('startButton').addEventListener('click', startGame);
            }
            
            // 位置合わせボタンの設定
            document.getElementById('calibrateButton').addEventListener('click', () => {
                // 最新のセンサー値で校正
                if (deviceHasOrientation) {
                    // 次のデバイスセンサーイベントで校正
                    isSensorCalibrated = false;
                } else {
                    alert('方向センサーが検出されませんでした。デバイスがジャイロセンサーをサポートしているか確認してください。');
                }
            });
            
            // 発射ボタンの設定
            document.getElementById('fireButton').addEventListener('click', fireBullet);
            
            // リスタートボタンの設定
            document.getElementById('restartButton').addEventListener('click', restartGame);
            
            // アニメーションの開始
            animate();
        }
        
        // 城の作成
        function createCastle() {
            castle = new THREE.Group();
            
            // 城壁
            const wallGeometry = new THREE.BoxGeometry(100, 20, 100);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = -10;
            castle.add(wall);
            
            // 天守閣
            const towerGeometry = new THREE.BoxGeometry(20, 30, 20);
            const towerMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.y = 15;
            castle.add(tower);
            
            // 屋根
            const roofGeometry = new THREE.ConeGeometry(15, 10, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 35;
            roof.rotation.y = Math.PI / 4;
            castle.add(roof);
            
            scene.add(castle);
        }
        
        // 敵の作成
        function createEnemy() {
            // 敵の種類をランダムに決定
            const enemyTypes = ['soldier', 'archer', 'knight'];
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            // 敵の初期設定（後でモデルで置き換え）
            let enemy = new THREE.Group();
            
            // 敵の特性設定
            switch (enemyType) {
                case 'soldier': // 通常兵士
                    enemy.userData.speed = 0.15 + Math.random() * 0.2;
                    enemy.userData.health = 1;
                    enemy.userData.type = 'soldier';
                    break;
                case 'archer': // 弓兵（細くて速い）
                    enemy.userData.speed = 0.25 + Math.random() * 0.2;
                    enemy.userData.health = 1;
                    enemy.userData.type = 'archer';
                    break;
                case 'knight': // 重装兵（大きくて遅い）
                    enemy.userData.speed = 0.08 + Math.random() * 0.1;
                    enemy.userData.health = 2;
                    enemy.userData.type = 'knight';
                    break;
            }
            
            // ランダムな位置（城の周りから）- 敵をグループ化して攻めてくるように調整
            const baseAngle = (Math.floor(Math.random() * 8) / 8) * Math.PI * 2; // 8方向からグループで攻めてくる
            const angleVariation = (Math.random() - 0.5) * 0.5; // グループ内での角度のばらつき
            const angle = baseAngle + angleVariation;
            const radius = 70 + Math.random() * 20;
            enemy.position.x = Math.cos(angle) * radius;
            enemy.position.z = Math.sin(angle) * radius;
            enemy.position.y = 0;
            
            // 敵の方向を設定
            enemy.userData.direction = new THREE.Vector3(0, 0, 0)
                .subVectors(new THREE.Vector3(0, 0, 0), enemy.position)
                .normalize();
            
            // GLTFモデルを読み込み、成功したらそのモデルを使用
            loadModel(enemyType)
                .then(model => {
                    // 既存のGROUPにモデルを追加
                    enemy.add(model);
                    
                    // アニメーション設定（モデルにアニメーションがある場合）
                    if (model.animations && model.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(model);
                        const action = mixer.clipAction(model.animations[0]);
                        action.play();
                        enemy.userData.mixer = mixer;
                        mixers.push(mixer);
                    }
                })
                .catch(error => {
                    console.error('モデル読み込みエラー:', error);
                    // モデル読み込み失敗時はフォールバックモデルを使用
                    const fallbackModel = createFallbackEnemy(enemyType);
                    enemy.add(fallbackModel);
                });
            
            scene.add(enemy);
            enemies.push(enemy);
        }
        
        // 敵の更新
        function updateEnemies(delta) {
            // 新しい敵の生成（頻度を大幅に上げる - 0.5秒ごとに1~3体）
            const spawnChance = 0.05 * delta * 60;
            
            // enemiesの最大数を制限（パフォーマンス対策）
            if (enemies.length < 50 && Math.random() < spawnChance) {
                // 一度に複数の敵を生成
                const enemyCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < enemyCount; i++) {
                    createEnemy();
                }
            }
            
            // アニメーションミキサーの更新
            for (let i = mixers.length - 1; i >= 0; i--) {
                mixers[i].update(delta);
            }
            
            // 敵の移動
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // モデル読み込み中に削除された可能性をチェック
                if (!scene.children.includes(enemy)) continue;
                
                // 天守閣に向かって移動
                enemy.position.x += enemy.userData.direction.x * enemy.userData.speed * delta * 60;
                enemy.position.z += enemy.userData.direction.z * enemy.userData.speed * delta * 60;
                
                // 進行方向を向く
                enemy.lookAt(new THREE.Vector3(0, enemy.position.y, 0));
                
                // 天守閣に到達したら削除
                const distanceToCenter = Math.sqrt(
                    enemy.position.x * enemy.position.x + 
                    enemy.position.z * enemy.position.z
                );
                
                if (distanceToCenter < 10) {
                    // アニメーションミキサーがある場合はリストから削除
                    if (enemy.userData.mixer) {
                        const mixerIndex = mixers.indexOf(enemy.userData.mixer);
                        if (mixerIndex !== -1) {
                            mixers.splice(mixerIndex, 1);
                        }
                    }
                    
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
        }
        
        // ウィンドウリサイズ時の処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // マウスクリック/タップ時の処理
        function onMouseClick(event) {
            if (!isGameRunning) return;
            
            // 発射ボタンやキャリブレーションボタンがクリックされた場合は弾を発射しない
            // （バブリングで両方が実行されることを防ぐ）
            const target = event.target;
            if (target.id === 'fireButton' || target.id === 'calibrateButton') {
                return;
            }
            
            // クリック位置を正規化
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // レイキャスト
            raycaster.setFromCamera(mouse, camera);
            
            // 弾丸を発射
            fireBullet();
        }
        
        // 弾を発射する
        function fireBullet() {
            if (!isGameRunning) return;
            
            // 弾丸を生成して発射
            createBullet();
            
            // カメラからのレイキャスト（中央から撃つ）
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // 敵との当たり判定
            const intersects = raycaster.intersectObjects(enemies);
            
            if (intersects.length > 0) {
                // 敵にヒット
                const hitEnemy = intersects[0].object;
                let enemyRoot = hitEnemy;
                
                // グループの親オブジェクトを見つける
                while (enemyRoot.parent && !enemies.includes(enemyRoot)) {
                    enemyRoot = enemyRoot.parent;
                }
                
                if (enemies.includes(enemyRoot)) {
                    // 敵のヘルスを減らす
                    if (!enemyRoot.userData.health) enemyRoot.userData.health = 1;
                    enemyRoot.userData.health--;
                    
                    if (enemyRoot.userData.health <= 0) {
                        // 敵を倒した
                        // アニメーションミキサーがある場合はリストから削除
                        if (enemyRoot.userData.mixer) {
                            const mixerIndex = mixers.indexOf(enemyRoot.userData.mixer);
                            if (mixerIndex !== -1) {
                                mixers.splice(mixerIndex, 1);
                            }
                        }
                        
                        scene.remove(enemyRoot);
                        enemies.splice(enemies.indexOf(enemyRoot), 1);
                        score++;
                        updateScore();
                    } else {
                        // 敵にダメージを与えた（モデルの場合は色を変えるのが難しいので、エフェクトだけ）
                        // ダメージエフェクト
                        const children = enemyRoot.children;
                        for (let i = 0; i < children.length; i++) {
                            if (children[i].material) {
                                // 一時的に赤く光らせる
                                const originalColor = children[i].material.color.clone();
                                children[i].material.emissive = new THREE.Color(0xff0000);
                                
                                // 0.3秒後に元に戻す
                                setTimeout(() => {
                                    if (children[i].material) {
                                        children[i].material.emissive = new THREE.Color(0x000000);
                                    }
                                }, 300);
                            }
                        }
                    }
                    
                    // ヒットエフェクト
                    createHitEffect(intersects[0].point);
                    
                    // サウンド効果
                    sounds.gunshot.play();
                    sounds.enemyDeath.play();
                }
            } else {
                // ミス
                sounds.gunshot.play();
            }
            
            // ボタンのアニメーション効果
            const fireButton = document.getElementById('fireButton');
            fireButton.style.transform = 'scale(0.9)';
            setTimeout(() => {
                fireButton.style.transform = 'scale(1)';
            }, 100);
        }
        
        // 弾丸を生成
        function createBullet() {
            // 弾丸のジオメトリとマテリアル
            const bulletGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // カメラの位置と向きに基づいて弾丸を配置
            bullet.position.copy(camera.position);
            
            // 弾丸の飛ぶ方向を計算
            const bulletDirection = new THREE.Vector3(0, 0, -1);
            bulletDirection.applyQuaternion(camera.quaternion);
            bullet.userData.direction = bulletDirection;
            bullet.userData.speed = 3;
            bullet.userData.lifeTime = 2; // 弾丸の寿命（秒）
            bullet.userData.elapsedTime = 0;
            
            // 弾丸光の追加
            const bulletLight = new THREE.PointLight(0xFFFF00, 1, 10);
            bullet.add(bulletLight);
            
            // 弾丸の軌跡を表現するトレイル
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xFFFF00, opacity: 0.5, transparent: true });
            const trailPositions = [];
            for (let i = 0; i < 20; i++) {
                trailPositions.push(bullet.position.x, bullet.position.y, bullet.position.z);
            }
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            bullet.userData.trail = trail;
            
            scene.add(bullet);
            scene.add(trail);
            
            bullets.push(bullet);
        }
        
        // ヒットエフェクトを生成
        function createHitEffect(position) {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 20;
            const particlePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = position.x;
                particlePositions[i * 3 + 1] = position.y;
                particlePositions[i * 3 + 2] = position.z;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xFF5500,
                size: 1,
                transparent: true,
                opacity: 1
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            
            // パーティクルに速度を設定
            particles.userData.velocities = [];
            for (let i = 0; i < particleCount; i++) {
                particles.userData.velocities.push({
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5,
                    z: (Math.random() - 0.5) * 0.5
                });
            }
            
            particles.userData.elapsedTime = 0;
            particles.userData.lifeTime = 1; // 1秒間表示
            
            scene.add(particles);
            effects.push(particles);
        }
        
        // デバイスの向きに応じてカメラを回転
        function onDeviceOrientation(event) {
            if (!isGameRunning) return;
            
            // デバイスがセンサーを持っていることを確認
            if (event.beta !== null && event.gamma !== null && event.alpha !== null) {
                deviceHasOrientation = true;
                
                const beta = event.beta;   // X軸周りの回転（-180〜180）
                const gamma = event.gamma; // Y軸周りの回転（-90〜90）
                const alpha = event.alpha; // Z軸周りの回転（0〜360）
                
                // センサーが校正されていない場合は初期値として設定
                if (!isSensorCalibrated) {
                    calibrateSensors(beta, gamma, alpha);
                }
                
                // 初期値からの相対的な変化を計算
                const adjustedBeta = beta - initialBeta;
                const adjustedGamma = gamma - initialGamma;
                // Z軸回転（alpha）は円環状なので特別な処理
                let adjustedAlpha = alpha - initialAlpha;
                if (adjustedAlpha > 180) adjustedAlpha -= 360;
                if (adjustedAlpha < -180) adjustedAlpha += 360;
                
                // ベータ値（前後の傾き）を制限
                const restrictedBeta = Math.max(-60, Math.min(60, adjustedBeta));
                
                // カメラの回転を設定（より敏感に反応するように係数を調整）
                camera.rotation.x = THREE.MathUtils.degToRad(restrictedBeta * 1.5);
                camera.rotation.y = THREE.MathUtils.degToRad(-adjustedGamma * 1.5);
                camera.rotation.z = THREE.MathUtils.degToRad(adjustedAlpha * 0.5); // Z軸の回転は弱めに
                
                // lookAtを使用して視点を更新
                const lookAtTarget = new THREE.Vector3(
                    Math.sin(THREE.MathUtils.degToRad(-adjustedGamma * 1.5)) * 50,
                    Math.sin(THREE.MathUtils.degToRad(restrictedBeta * 1.5)) * 30,
                    -Math.cos(THREE.MathUtils.degToRad(-adjustedGamma * 1.5)) * 50
                );
                camera.lookAt(lookAtTarget);
                
                // デバッグ情報（開発時に便利）
                // console.log(`Beta: ${adjustedBeta.toFixed(2)}, Gamma: ${adjustedGamma.toFixed(2)}, Alpha: ${adjustedAlpha.toFixed(2)}`);
            }
        }
        
        // センサーを校正
        function calibrateSensors(beta, gamma, alpha) {
            initialBeta = beta;
            initialGamma = gamma;
            initialAlpha = alpha;
            isSensorCalibrated = true;
            
            console.log(`センサー校正完了: Beta=${initialBeta.toFixed(2)}, Gamma=${initialGamma.toFixed(2)}, Alpha=${initialAlpha.toFixed(2)}`);
            
            // 校正完了のフィードバック
            const calibrationMessage = document.createElement('div');
            calibrationMessage.textContent = '位置合わせ完了!';
            calibrationMessage.style.position = 'absolute';
            calibrationMessage.style.top = '50%';
            calibrationMessage.style.left = '50%';
            calibrationMessage.style.transform = 'translate(-50%, -50%)';
            calibrationMessage.style.backgroundColor = 'rgba(0, 150, 0, 0.7)';
            calibrationMessage.style.color = 'white';
            calibrationMessage.style.padding = '15px';
            calibrationMessage.style.borderRadius = '10px';
            calibrationMessage.style.zIndex = '1000';
            
            document.body.appendChild(calibrationMessage);
            
            // 2秒後にメッセージを削除
            setTimeout(() => {
                document.body.removeChild(calibrationMessage);
            }, 2000);
        }
        
        // ゲームの開始
        function startGame() {
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('calibrateButton').style.display = 'block';
            document.getElementById('fireButton').style.display = 'block';
            isGameRunning = true;
            gameTime = 30;
            score = 0;
            updateScore();
            updateTimer();
            
            // センサーの校正をリセット
            isSensorCalibrated = false;
            
            // 既存の敵をクリア
            for (const enemy of enemies) {
                scene.remove(enemy);
            }
            enemies = [];
            
            // 既存の弾丸をクリア
            for (const bullet of bullets) {
                scene.remove(bullet);
                if (bullet.userData.trail) {
                    scene.remove(bullet.userData.trail);
                }
            }
            bullets = [];
            
            // 既存のエフェクトをクリア
            for (const effect of effects) {
                scene.remove(effect);
            }
            effects = [];
            
            // カメラの位置をリセット
            camera.position.set(0, 50, 0);
            camera.rotation.set(0, 0, 0);
            camera.lookAt(0, 0, -100);
            
            // サウンド効果
            sounds.gameStart.play();
            
            // ARの許可を要求
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                    .then(function(stream) {
                        const video = document.createElement('video');
                        video.srcObject = stream;
                        video.play();
                        
                        const texture = new THREE.VideoTexture(video);
                        scene.background = texture;
                    })
                    .catch(function(error) {
                        console.error('ARの初期化に失敗しました:', error);
                        // ARが使えない場合は代替背景を設定
                        scene.background = new THREE.Color(0x87CEEB);
                    });
            }
            
            // 1秒後に位置合わせを促すメッセージを表示
            setTimeout(() => {
                if (!isSensorCalibrated && deviceHasOrientation) {
                    const calibrationPrompt = document.createElement('div');
                    calibrationPrompt.textContent = 'タブレットを水平にして「位置合わせ」ボタンを押してください';
                    calibrationPrompt.style.position = 'absolute';
                    calibrationPrompt.style.bottom = '70px';
                    calibrationPrompt.style.right = '20px';
                    calibrationPrompt.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    calibrationPrompt.style.color = 'white';
                    calibrationPrompt.style.padding = '10px';
                    calibrationPrompt.style.borderRadius = '5px';
                    calibrationPrompt.style.zIndex = '1000';
                    calibrationPrompt.id = 'calibrationPrompt';
                    
                    document.body.appendChild(calibrationPrompt);
                    
                    // 5秒後にメッセージを消す
                    setTimeout(() => {
                        const prompt = document.getElementById('calibrationPrompt');
                        if (prompt) {
                            document.body.removeChild(prompt);
                        }
                    }, 5000);
                }
            }, 1000);
        }
        
        // ゲームの再開
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            startGame();
        }
        
        // スコアの更新
        function updateScore() {
            document.getElementById('score').textContent = `スコア: ${score}`;
            document.getElementById('finalScore').textContent = score;
        }
        
        // タイマーの更新
        function updateTimer() {
            document.getElementById('timer').textContent = `残り時間: ${Math.ceil(gameTime)}秒`;
        }
        
        // ゲーム終了
        function endGame() {
            isGameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('calibrateButton').style.display = 'none';
            document.getElementById('fireButton').style.display = 'none';
            
            // 校正プロンプトが残っていたら削除
            const prompt = document.getElementById('calibrationPrompt');
            if (prompt) {
                document.body.removeChild(prompt);
            }
            
            // サウンド効果
            sounds.gameOver.play();
        }
        
        // アニメーション
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (isGameRunning) {
                // ゲーム時間の更新
                gameTime -= delta;
                updateTimer();
                
                if (gameTime <= 0) {
                    endGame();
                }
                
                // 敵の更新
                updateEnemies(delta);
                
                // 弾丸の更新
                updateBullets(delta);
                
                // エフェクトの更新
                updateEffects(delta);
                
                // カメラに付属するスポットライトの更新
                updateLights();
            }
            
            renderer.render(scene, camera);
        }
        
        // ライトの更新
        function updateLights() {
            // カメラに付属するスポットライトを更新（常にカメラの方向を照らす）
            camera.children.forEach(child => {
                if (child.isSpotLight) {
                    child.target.position.set(
                        camera.position.x + Math.sin(camera.rotation.y) * 10,
                        camera.position.y + Math.sin(-camera.rotation.x) * 10,
                        camera.position.z + Math.cos(camera.rotation.y) * 10
                    );
                    child.target.updateMatrixWorld();
                }
            });
        }
        
        // 弾丸の更新
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // 弾丸の移動
                bullet.position.x += bullet.userData.direction.x * bullet.userData.speed;
                bullet.position.y += bullet.userData.direction.y * bullet.userData.speed;
                bullet.position.z += bullet.userData.direction.z * bullet.userData.speed;
                
                // 弾丸のトレイル更新
                const trail = bullet.userData.trail;
                const positions = trail.geometry.attributes.position.array;
                
                // トレイルの位置を更新（最初の点を弾丸の現在位置に）
                positions[0] = bullet.position.x;
                positions[1] = bullet.position.y;
                positions[2] = bullet.position.z;
                
                // 残りの点を後ろにシフト
                for (let j = positions.length - 3; j >= 3; j -= 3) {
                    positions[j] = positions[j - 3];
                    positions[j + 1] = positions[j - 2];
                    positions[j + 2] = positions[j - 1];
                }
                
                trail.geometry.attributes.position.needsUpdate = true;
                
                // 弾丸の寿命を減らす
                bullet.userData.elapsedTime += delta;
                if (bullet.userData.elapsedTime > bullet.userData.lifeTime) {
                    scene.remove(bullet);
                    scene.remove(trail);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // 敵との衝突判定
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distance = bullet.position.distanceTo(enemy.position);
                    
                    if (distance < 3) { // 敵のサイズに応じて調整
                        // 敵のヘルスを減らす
                        enemy.userData.health--;
                        
                        if (enemy.userData.health <= 0) {
                            // 敵を倒した
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            score++;
                            updateScore();
                            
                            // 爆発エフェクト
                            createHitEffect(enemy.position);
                            
                            // サウンド効果
                            sounds.enemyDeath.play();
                        } else {
                            // 敵にダメージを与えた（色を変える）
                            enemy.material.color.setHex(0xFF6666);
                            
                            // ヒットエフェクト
                            createHitEffect(bullet.position);
                        }
                        
                        // 弾丸を削除
                        scene.remove(bullet);
                        scene.remove(trail);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        // エフェクトの更新
        function updateEffects(delta) {
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                
                // パーティクルの移動
                const positions = effect.geometry.attributes.position.array;
                const velocities = effect.userData.velocities;
                
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += velocities[j / 3].x;
                    positions[j + 1] += velocities[j / 3].y;
                    positions[j + 2] += velocities[j / 3].z;
                    
                    // 重力の影響
                    velocities[j / 3].y -= 0.01;
                }
                
                effect.geometry.attributes.position.needsUpdate = true;
                
                // 透明度の更新
                effect.userData.elapsedTime += delta;
                const lifeRatio = effect.userData.elapsedTime / effect.userData.lifeTime;
                effect.material.opacity = 1 - lifeRatio;
                
                // 寿命が尽きたらエフェクトを削除
                if (effect.userData.elapsedTime > effect.userData.lifeTime) {
                    scene.remove(effect);
                    effects.splice(i, 1);
                }
            }
        }
        
        // 初期化の実行
        init();
    </script>
</body>
</html>